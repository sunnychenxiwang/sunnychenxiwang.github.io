<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="基础算法\rps:（https://www.acwing.com/） 同上链接付费课程同步以及自己的完善笔记 1.基础算法\r1.排序\r快速排序\r时间复杂度O（nlogn） 是不稳定的 但可以设立一个二维下标这样便能区分相同的数，使其变为稳定的 基本思路（分治思想，可不仅用于排序） 实在不行也可用暴力 开辟两个额外空间 同时注意一下边界问题 1.确定分界点的值x(一般为：q[l] ,q[r] ,q[(l+r)/2], 随机数)。 2.把小于等于x的放在左边，把大于等于x的放在右边(较好的策略(核心思路)：设置两个指针(i,j)分别指向数组开头和结尾。若i所指向的大于x则停下，否则继续自增走下去。若j所指向的小于x则停下，否则继续自减走下去。若二者都停下则交换。若i&gt;j，则进行第三步操作。) 3.递归处理分界点左右两边 更好地理解：快速排序先通过确立某个flag通过粗略排序得到有一定顺序的数组，再依次递归下去 当长度为2或者1时。整个数组已排好 核心代码片段 //分界条件 为i时 不能为l + r &gt;&gt; 1（当l为 r - 1时） 和l 死循环 //当分界条件为j时 不能为 l + r + 1 &gt;&gt; 1和 r void quick_sort(int l, int r) { if(l &gt;= r) return; int i = l - 1,j = r + 1; int x = arr[(i + j &gt;&gt; 1)]; while(i &lt; j) { do i ++;while(arr[i] &lt; x); do j --;while(arr[j] &gt; x); if(i &lt; j) swap(arr[i], arr[j]); } quick_sort(l, j); quick_sort(j + 1, r); } 快速选择算法 题目第K个数 时间复杂度O(n)：每次只用递归其中一边">
<title>数据结构与算法</title>

<link rel='canonical' href='http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/'>

<link rel="stylesheet" href="/scss/style.min.e8c7fca7d1c9294aa7a4f3426c225ee26540f7d94e39be0b5a4a5c8a49ca5a25.css"><meta property='og:title' content="数据结构与算法">
<meta property='og:description' content="基础算法\rps:（https://www.acwing.com/） 同上链接付费课程同步以及自己的完善笔记 1.基础算法\r1.排序\r快速排序\r时间复杂度O（nlogn） 是不稳定的 但可以设立一个二维下标这样便能区分相同的数，使其变为稳定的 基本思路（分治思想，可不仅用于排序） 实在不行也可用暴力 开辟两个额外空间 同时注意一下边界问题 1.确定分界点的值x(一般为：q[l] ,q[r] ,q[(l+r)/2], 随机数)。 2.把小于等于x的放在左边，把大于等于x的放在右边(较好的策略(核心思路)：设置两个指针(i,j)分别指向数组开头和结尾。若i所指向的大于x则停下，否则继续自增走下去。若j所指向的小于x则停下，否则继续自减走下去。若二者都停下则交换。若i&gt;j，则进行第三步操作。) 3.递归处理分界点左右两边 更好地理解：快速排序先通过确立某个flag通过粗略排序得到有一定顺序的数组，再依次递归下去 当长度为2或者1时。整个数组已排好 核心代码片段 //分界条件 为i时 不能为l + r &gt;&gt; 1（当l为 r - 1时） 和l 死循环 //当分界条件为j时 不能为 l + r + 1 &gt;&gt; 1和 r void quick_sort(int l, int r) { if(l &gt;= r) return; int i = l - 1,j = r + 1; int x = arr[(i + j &gt;&gt; 1)]; while(i &lt; j) { do i ++;while(arr[i] &lt; x); do j --;while(arr[j] &gt; x); if(i &lt; j) swap(arr[i], arr[j]); } quick_sort(l, j); quick_sort(j + 1, r); } 快速选择算法 题目第K个数 时间复杂度O(n)：每次只用递归其中一边">
<meta property='og:url' content='http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/'>
<meta property='og:site_name' content='wcx blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-08-15T22:36:14&#43;08:00'/><meta property='article:modified_time' content='2024-08-15T22:36:14&#43;08:00'/>
<meta name="twitter:title" content="数据结构与算法">
<meta name="twitter:description" content="基础算法\rps:（https://www.acwing.com/） 同上链接付费课程同步以及自己的完善笔记 1.基础算法\r1.排序\r快速排序\r时间复杂度O（nlogn） 是不稳定的 但可以设立一个二维下标这样便能区分相同的数，使其变为稳定的 基本思路（分治思想，可不仅用于排序） 实在不行也可用暴力 开辟两个额外空间 同时注意一下边界问题 1.确定分界点的值x(一般为：q[l] ,q[r] ,q[(l+r)/2], 随机数)。 2.把小于等于x的放在左边，把大于等于x的放在右边(较好的策略(核心思路)：设置两个指针(i,j)分别指向数组开头和结尾。若i所指向的大于x则停下，否则继续自增走下去。若j所指向的小于x则停下，否则继续自减走下去。若二者都停下则交换。若i&gt;j，则进行第三步操作。) 3.递归处理分界点左右两边 更好地理解：快速排序先通过确立某个flag通过粗略排序得到有一定顺序的数组，再依次递归下去 当长度为2或者1时。整个数组已排好 核心代码片段 //分界条件 为i时 不能为l + r &gt;&gt; 1（当l为 r - 1时） 和l 死循环 //当分界条件为j时 不能为 l + r + 1 &gt;&gt; 1和 r void quick_sort(int l, int r) { if(l &gt;= r) return; int i = l - 1,j = r + 1; int x = arr[(i + j &gt;&gt; 1)]; while(i &lt; j) { do i ++;while(arr[i] &lt; x); do j --;while(arr[j] &gt; x); if(i &lt; j) swap(arr[i], arr[j]); } quick_sort(l, j); quick_sort(j + 1, r); } 快速选择算法 题目第K个数 时间复杂度O(n)：每次只用递归其中一边">
  


    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu13739649187745961479.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">wcx blog</a></h1>
            <h2 class="site-description"></h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Aug 15, 2024</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    71 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="基础算法">基础算法
</h1><p>ps:（https://www.acwing.com/） 同上链接付费课程同步以及自己的完善笔记</p>
<h2 id="1基础算法">1.基础算法
</h2><h3 id="1排序">1.排序
</h3><h4 id="快速排序">快速排序
</h4><p><strong>时间复杂度O（nlogn）</strong></p>
<p>是不稳定的 但可以设立一个二维下标这样便能区分相同的数，使其变为稳定的</p>
<p>基本思路（<strong>分治思想，可不仅用于排序</strong>） 实在不行也可用暴力 开辟两个额外空间  同时注意一下边界问题</p>
<p>1.确定分界点的值x(一般为：q[l] ,q[r] ,q[(l+r)/2], 随机数)。</p>
<p>2.把小于等于x的放在左边，把大于等于x的放在右边(较好的策略(核心思路)：设置两个指针(i,j)分别指向数组开头和结尾。若i所指向的大于x则停下，否则继续自增走下去。若j所指向的小于x则停下，否则继续自减走下去。若二者都停下则交换。若i&gt;j，则进行第三步操作。)</p>
<p>3.递归处理分界点左右两边</p>
<p><strong>更好地理解：快速排序先通过确立某个flag通过粗略排序得到有一定顺序的数组，再依次递归下去 当长度为2或者1时。整个数组已排好</strong></p>
<p>核心代码片段</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//分界条件 为i时 不能为l + r &gt;&gt; 1（当l为 r - 1时） 和l 死循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//当分界条件为j时 不能为 l + r + 1 &gt;&gt; 1和 r
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quick_sort</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">&gt;=</span> r) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>,j <span style="color:#f92672">=</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> arr[(i <span style="color:#f92672">+</span> j <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>)];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i <span style="color:#f92672">&lt;</span> j)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> i <span style="color:#f92672">++</span>;<span style="color:#66d9ef">while</span>(arr[i] <span style="color:#f92672">&lt;</span> x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> j <span style="color:#f92672">--</span>;<span style="color:#66d9ef">while</span>(arr[j] <span style="color:#f92672">&gt;</span> x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> j) swap(arr[i], arr[j]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    quick_sort(l, j);
</span></span><span style="display:flex;"><span>    quick_sort(j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>快速选择算法 题目第K个数 <strong>时间复杂度O(n)：每次只用递归其中一边</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">quicksort</span>(<span style="color:#66d9ef">int</span> l,<span style="color:#66d9ef">int</span> r,<span style="color:#66d9ef">int</span> k){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">&gt;=</span> r) <span style="color:#66d9ef">return</span> q<span style="color:#f92672">[</span>r<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> q<span style="color:#f92672">[</span>l<span style="color:#f92672">]</span>,i <span style="color:#f92672">=</span> l <span style="color:#f92672">-</span> 1,j <span style="color:#f92672">=</span> r <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(i <span style="color:#f92672">&lt;</span> j){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(q<span style="color:#f92672">[++</span> i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> x);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(q<span style="color:#f92672">[--</span> j<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> x);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> j) swap(i,j);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sl <span style="color:#f92672">=</span> j <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(sl <span style="color:#f92672">&gt;=</span> k) <span style="color:#66d9ef">return</span> quicksort(l,j,k);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> quicksort(j <span style="color:#f92672">+</span> 1,r,k <span style="color:#f92672">-</span> sl);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="归并排序">归并排序
</h4><p><strong>时间复杂度O(nlogn)</strong></p>
<p>是稳定的 即对于两个相同的数排完序后位置与之前的保持不变</p>
<p>基本思想 <strong>分治法，可不止用于排序 其他算法也可采样分治思想</strong></p>
<p>1.确定分界点 mid=（l+r)/2 是下标 不同于快排 以值为分界点</p>
<p>2.递归排序</p>
<p>3.归并 把两个数组合二为一</p>
<p><strong>更好的理解：显然归并排序先通过层层递归到最小长度为2的情况，即先排序好一个个长度为2或者1的数组，再归并成一个个为4或3的数组&hellip;&hellip;.依次向上归并即可得到重组后的数组。其顺序与快速排序恰好相反。</strong></p>
<p>关键代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge_sort</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)  <span style="color:#75715e">// 归并排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">&gt;=</span> r) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (l <span style="color:#f92672">+</span> r) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    merge_sort(l, mid), merge_sort(mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> l, j <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i <span style="color:#f92672">&lt;=</span> mid <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;=</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(arr[i] <span style="color:#f92672">&lt;=</span> arr[j]) temp[k <span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> arr[i <span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> temp[k <span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> arr[j <span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i <span style="color:#f92672">&lt;=</span> mid) temp[k <span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> arr[i <span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(j <span style="color:#f92672">&lt;=</span> r) temp[k <span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> arr[j <span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> l,j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;=</span> r;i <span style="color:#f92672">++</span>,j <span style="color:#f92672">++</span>) arr[i] <span style="color:#f92672">=</span> temp[j];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2二分法">2.二分法
</h3><p>整数二分</p>
<p>注意边界问题 有时需要多次调试</p>
<p>原理：<strong>有单调性一定可以二分 没有单调性也可能二分 所以二分本质不是单调性。本质可定义为，将整个区间一分为二，左边满足某种性质，右边不满足这种性质，则可以找到这样的边界点</strong></p>
<p>本质：分治思想 比如左半边满足这种性质check 右半边是不满足的</p>
<p>最后l和r会相等</p>
<p>最终结果如何：可以寻找左右两半边的边界。<strong>最终结果l = r</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//两个模板</span>
</span></span><span style="display:flex;"><span>bool <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">int</span> x) {<span style="color:#75715e">/* ... */</span>} <span style="color:#75715e">// 检查x是否满足某种性质</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bsearch_1</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (check(mid)) r <span style="color:#f92672">=</span> mid;    <span style="color:#75715e">// check()判断mid是否满足性质</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> l;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bsearch_2</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">+</span> 1 <span style="color:#f92672">&gt;&gt;</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (check(mid)) l <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> l;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3高精度">3.高精度
</h3><p>高精度加法</p>
<p>模拟竖式加法（加法器：Ai+BI+Ci-1）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> add(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> B)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//进位标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> A.size() <span style="color:#f92672">||</span> i <span style="color:#f92672">&lt;</span> B.size();i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> A.size()) t <span style="color:#f92672">+=</span> A[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> B.size()) t <span style="color:#f92672">+=</span> B[i];
</span></span><span style="display:flex;"><span>        C.push_back(t <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//是否还有进位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(t) C.push_back(t);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> C;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//更完美写法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">vector&lt;int&gt; add(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    vector&lt;int&gt; C;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    int t = 0;//进位标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    for(int i = 0;i &lt; A.size() || i &lt; B.size() || t;i ++ )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        if(i &lt; A.size()) t += A[i];
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        if(i &lt; B.size()) t += B[i];
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        C.push_back(t % 10);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        t /= 10;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    return C;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    string a, b;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> A, B;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> a.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> ) A.push_back(a[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> b.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> ) B.push_back(b[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C <span style="color:#f92672">=</span> add(A, B);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> C.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> ) printf(<span style="color:#e6db74">&#34;%d&#34;</span>,C[i]);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>高精度减法</p>
<p>模拟竖式减法 需记录是否借位 可只需写出较大大的减较小的即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> B)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(A.size() <span style="color:#f92672">!=</span> B.size()) <span style="color:#66d9ef">return</span> A.size() <span style="color:#f92672">&gt;</span> B.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> A.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(A[i] <span style="color:#f92672">!=</span> B[i]) <span style="color:#66d9ef">return</span> A[i] <span style="color:#f92672">&gt;</span> B[i];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sub(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> B)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//借位标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> A.size();i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> A[i] <span style="color:#f92672">-</span> t;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> B.size()) t <span style="color:#f92672">-=</span> B[i];
</span></span><span style="display:flex;"><span>        C.push_back((t <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>);<span style="color:#75715e">//简洁写法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(t <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//下一个是否借位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//去除前导 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(C.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> C.back() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) C.pop_back();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> C;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    string a, b;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> A, B;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> a.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> ) A.push_back(a[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> b.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> ) B.push_back(b[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//先比较 用较大的减小的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(cmp(A, B))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        C <span style="color:#f92672">=</span> sub(A, B);    
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        C <span style="color:#f92672">=</span> sub(B, A);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;-&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> C.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> ) printf(<span style="color:#e6db74">&#34;%d&#34;</span>,C[i]);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>高精度乘法</p>
<p>模拟竖式乘法 需记录进位标志。同时这里往往是一个很大的 乘以一个位数较少的 需每次用大的数的每一位直接乘以小的数</p>
<p>如1≤A的长度≤100000, 0≤B≤10000</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mul(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, <span style="color:#66d9ef">int</span> B)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//借位标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//完美避开 是否进位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> A.size() <span style="color:#f92672">||</span> t;i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> A.size()) t <span style="color:#f92672">+=</span> A[i] <span style="color:#f92672">*</span> B;<span style="color:#75715e">//乘出是一个多位数 23456
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        C.push_back(t <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>);<span style="color:#75715e">//每次只取个位 其他保留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        t <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//去除前导0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(C.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> C.back() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) C.pop_back();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> C;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A, int B)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    vector&lt;int&gt; C;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    int t = 0;//借位标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    for(int i = 0;i &lt; A.size();i ++ )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        t += A[i] * B;//乘出是一个多位数 23456
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        C.push_back(t % 10);//每次只取个位 其他保留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        t /= 10;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    //是否还有进位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    while(t) C.push_back(t % 10),t /= 10;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    //去除前导0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    return C;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    string a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> A;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> a.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> ) A.push_back(a[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C <span style="color:#f92672">=</span> mul(A, b);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> C.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> ) printf(<span style="color:#e6db74">&#34;%d&#34;</span>,C[i]);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>高精度除法</p>
<p>模拟竖式除法：从最高位开始计算 仍然是一个高精度被除数和一个低精度除数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> div(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, <span style="color:#66d9ef">int</span> B, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C;<span style="color:#75715e">//商
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#75715e">//余数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//从最高位计算
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> A.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> r <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> A[i];<span style="color:#75715e">//模拟竖式除法 高位不够需右移的过程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        C.push_back(r <span style="color:#f92672">/</span> B);
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">%=</span> B;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    reverse(C.begin(), C.end());
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//去除前导0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(C.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> C.back() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) C.pop_back();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> C;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    string a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> A;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> a.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> ) A.push_back(a[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> r;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C <span style="color:#f92672">=</span> div(A, b, r);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> C.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">--</span> ) printf(<span style="color:#e6db74">&#34;%d&#34;</span>,C[i]);
</span></span><span style="display:flex;"><span>    puts(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;%d&#34;</span>, r);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="4前缀和与差分">4.前缀和与差分
</h3><p>前缀和：对于数组arr[N] = {a<!-- raw HTML omitted -->1<!-- raw HTML omitted -->,a<!-- raw HTML omitted -->2<!-- raw HTML omitted -->,a<!-- raw HTML omitted -->3<!-- raw HTML omitted -->,a<!-- raw HTML omitted -->4<!-- raw HTML omitted -->,&hellip;} 可以计算前缀和数组s,s<!-- raw HTML omitted -->i<!-- raw HTML omitted --> = s<!-- raw HTML omitted -->i-1<!-- raw HTML omitted --> + a<!-- raw HTML omitted -->i<!-- raw HTML omitted --></p>
<p>前缀和思想</p>
<ul>
<li>不仅仅只针对于求和运算 也同样适用于其他运算：乘积、异或（参见最大异或和）等</li>
<li><strong>最主要的思想：预处理。预处理后的查询，时间复杂度为O(1)，经典的空间换时间</strong></li>
</ul>
<p>前缀和</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            s<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>二维前缀和 s(i, j) = g(i, j) + s(i - 1, j) + s(i, j - 1) - s(i - 1, j - 1)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1010</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, m, q;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> s[N][N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>q);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> m; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>s[i][j]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> m; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            s[i][j] <span style="color:#f92672">+=</span> s[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> s[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> s[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (q <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x1, y1, x2, y2;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>x1, <span style="color:#f92672">&amp;</span>y1, <span style="color:#f92672">&amp;</span>x2, <span style="color:#f92672">&amp;</span>y2);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, s[x2][y2] <span style="color:#f92672">-</span> s[x1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][y2] <span style="color:#f92672">-</span> s[x2][y1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> s[x1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][y1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>差分</p>
<p>对于一个数组a1，a2，&hellip; an,构造一个数组b1，b2，&hellip; bn使得a数组是b数组的前缀和。即a1=b1;a2=b1+b2;&hellip;&hellip;an=b1+b2+&hellip;._bn（逆向推导即可得到差分公式）</p>
<p>作用：对于求原数组 可用**O(n)**时间内求出原数组</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            a[i] <span style="color:#f92672">=</span> sc.nextInt();
</span></span><span style="display:flex;"><span>            b[i] <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">-</span> a[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> m;i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> sc.nextInt();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> sc.nextInt();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> sc.nextInt();
</span></span><span style="display:flex;"><span>            b[l] <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(r <span style="color:#f92672">&lt;</span> n) b[r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-=</span> c;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span><span style="color:#75715e">//后面再对b数组做一次前缀和 即得所求原始数组
</span></span></span></code></pre></div><p>二维差分：不用关心具体公式如何推导 只用关心需求即可。由需求可得a[i, j]为b[i, j]的前缀和，则有a[i, j] = b[1,1] + b[1, 2] + b[1, 3] + &hellip;. b[1,j] + b[2, 1] + b[2, 2] + &hellip; b[i, j] 。则对于b[i, j] + c则有(i, j)到（n，m）的和将都加上c。</p>
<p>最后对b数组求二维前缀和即可得原数组</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1010</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, m, q;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[N][N], b[N][N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> x1, <span style="color:#66d9ef">int</span> y1, <span style="color:#66d9ef">int</span> x2, <span style="color:#66d9ef">int</span> y2, <span style="color:#66d9ef">int</span> c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    b[x1][y1] <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>    b[x2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][y1] <span style="color:#f92672">-=</span> c;
</span></span><span style="display:flex;"><span>    b[x1][y2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-=</span> c;
</span></span><span style="display:flex;"><span>    b[x2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][y2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>q);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> m; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>a[i][j]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//初始数组b为全0 更新后可得b数组的前缀和为a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> m; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            insert(i, j, i, j, a[i][j]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (q <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x1, y1, x2, y2, c;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> x1 <span style="color:#f92672">&gt;&gt;</span> y1 <span style="color:#f92672">&gt;&gt;</span> x2 <span style="color:#f92672">&gt;&gt;</span> y2 <span style="color:#f92672">&gt;&gt;</span> c;
</span></span><span style="display:flex;"><span>        insert(x1, y1, x2, y2, c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> m; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            b[i][j] <span style="color:#f92672">+=</span> b[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> b[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> b[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> m; j <span style="color:#f92672">++</span> ) printf(<span style="color:#e6db74">&#34;%d &#34;</span>, b[i][j]);
</span></span><span style="display:flex;"><span>        puts(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span></code></pre></div><h3 id="5双指针算法">5.双指针算法
</h3><p>先用暴力 再用双指针优化 O(N<!-- raw HTML omitted -->2<!-- raw HTML omitted -->) ——&gt;O(N) 核心思想：<strong>两个指针的移动次数不会超过2n</strong></p>
<p>常用经典双指针：</p>
<ul>
<li>i和j分别位于一个数组的两端</li>
<li>i和j分别位于两个数组的开头</li>
</ul>
<p>最长连续不重复元素</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[N], s[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> a[i];
</span></span><span style="display:flex;"><span>        s[a[i]] <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(s[a[i]] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">--</span> s[a[j <span style="color:#f92672">++</span>]];
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> max(i <span style="color:#f92672">-</span> j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> res <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>数组元素的目标和</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, m, k;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[N], b[N];
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define read(x) scanf(&#34;%d&#34;,&amp;x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    read(n), read(m), read(k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span> ) read(a[i]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i <span style="color:#f92672">++</span> ) read(b[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> a[i] <span style="color:#f92672">+</span> b[j] <span style="color:#f92672">&gt;</span> k) j <span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> a[i] <span style="color:#f92672">+</span> b[j] <span style="color:#f92672">==</span> k) printf(<span style="color:#e6db74">&#34;%d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, j);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="6位运算">6.位运算
</h3><p><strong>不会单独考，但涉及到0，1的 数组 矩阵 可考虑用二进制的数字代替：参考费解的开关；以及加快某些计算速度</strong></p>
<p>常规操作</p>
<p>1.求某个数第k位是0或1：可先&raquo;右移k位至个位然后异或&amp;1.</p>
<p>2.lowbit运算：返回第一个1 如100101000 则返回 1000</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lowbit</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> x <span style="color:#f92672">&amp;</span> <span style="color:#f92672">-</span>x;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>-x等于x的补码等于x求反+1</p>
<p>如：x = 100101000</p>
<p>~x + 1 = 011010111 + 1 = 011011000</p>
<h3 id="7离散化">7.离散化
</h3><p>数据量范围很大（如10<!-- raw HTML omitted -->9<!-- raw HTML omitted -->）&gt;10<!-- raw HTML omitted -->5<!-- raw HTML omitted --> 但是很稀疏 能用到的数据量可能只有10<!-- raw HTML omitted -->5<!-- raw HTML omitted --> 不然可以考虑前缀和 直接前缀和可能会超过内存限制</p>
<p>离散化：把所有用到的下标映射成从1开始的自然数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">3e5</span> <span style="color:#f92672">+</span><span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[N];<span style="color:#75715e">//存储映射后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> PII;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> all;<span style="color:#75715e">//将所有用到的下标 离散化为更小区间的数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span>PII<span style="color:#f92672">&gt;</span> query, add;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,r <span style="color:#f92672">=</span> all.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(l <span style="color:#f92672">&lt;</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (l <span style="color:#f92672">+</span> r) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(all[mid] <span style="color:#f92672">&gt;=</span> x) r <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//从1开始 便于后面求前缀和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n, m;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x, c;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>x, <span style="color:#f92672">&amp;</span>c);
</span></span><span style="display:flex;"><span>        add.push_back({x, c});
</span></span><span style="display:flex;"><span>        all.push_back(x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (m <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> l, r;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>l, <span style="color:#f92672">&amp;</span>r);
</span></span><span style="display:flex;"><span>        query.push_back({l, r});
</span></span><span style="display:flex;"><span>        all.push_back(l);
</span></span><span style="display:flex;"><span>        all.push_back(r);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//去重并排序所有下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//先排序 unique是每次比较相邻的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sort(all.begin(), all.end());
</span></span><span style="display:flex;"><span>    all.erase(unique(all.begin(), all.end()), all.end());
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//寻找下标 二分法 logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t : add)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> t.first, c <span style="color:#f92672">=</span> t.second;
</span></span><span style="display:flex;"><span>        a[find(x)] <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&lt;=</span> all.size();i <span style="color:#f92672">++</span>) a[i] <span style="color:#f92672">+=</span> a[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> item : query)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> find(item.first), r <span style="color:#f92672">=</span> find(item.second);
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> a[r] <span style="color:#f92672">-</span> a[l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="8区间合并">8.区间合并
</h3><p>目标：快速合并有交集的区间。方法：1.按区间左端点排序2.扫描并合并</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> PII;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100010</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>PII<span style="color:#f92672">&gt;</span> seg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> l, r;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> l <span style="color:#f92672">&gt;&gt;</span> r;
</span></span><span style="display:flex;"><span>        seg.push_back({l, r});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    sort(seg.begin(), seg.end());
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> st <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2e9</span>, ed <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2e9</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>PII<span style="color:#f92672">&gt;</span> res;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t : seg)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> t.first, r <span style="color:#f92672">=</span> t.second;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(ed <span style="color:#f92672">&lt;</span> l) 
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(st <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2e9</span>)
</span></span><span style="display:flex;"><span>                res.push_back({l, r});
</span></span><span style="display:flex;"><span>            st <span style="color:#f92672">=</span> l, ed <span style="color:#f92672">=</span> r;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> ed <span style="color:#f92672">=</span> max(ed, r);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(st <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2e9</span>) res.push_back({st, ed});
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> res.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="9递归">9.递归
</h3><h3 id="10递推">10.递推
</h3><p>递推思想参照：费解的开关、翻硬币、砖块：<strong>确定完状态枚举</strong>。一定要理清楚思路下手，不然没用</p>
<h4 id="砖块">砖块
</h4><p>思路分析</p>
<ul>
<li>最后的状态共两种：全白、全黑。分别枚举即可</li>
<li>同一个位置操作多次等于没操作</li>
<li>如果枚举的最终状态是全白，而第一个点是白则不操作（后面状态依次传递），而第一个点是黑则翻转（后面状态依次传递）</li>
</ul>
<p>代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> t;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            String s <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> s.<span style="color:#a6e22e">toCharArray</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> b <span style="color:#f92672">=</span> a.<span style="color:#a6e22e">clone</span>();<span style="color:#75715e">//深拷贝</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>check(a,<span style="color:#e6db74">&#39;W&#39;</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>check(b,<span style="color:#e6db74">&#39;B&#39;</span>))
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#f92672">-</span>1);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> array,<span style="color:#66d9ef">char</span> flag){
</span></span><span style="display:flex;"><span>        Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> array.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> flag){
</span></span><span style="display:flex;"><span>                update(array,i);
</span></span><span style="display:flex;"><span>                update(array,i <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>                queue.<span style="color:#a6e22e">offer</span>(i);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> queue.<span style="color:#a6e22e">size</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(array<span style="color:#f92672">[</span>array.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> flag) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(queue.<span style="color:#a6e22e">size</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(queue.<span style="color:#a6e22e">size</span>() <span style="color:#f92672">&gt;</span> 0)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> queue.<span style="color:#a6e22e">poll</span>() <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">print</span>(t <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(tmp <span style="color:#f92672">!=</span> 0) System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> array,<span style="color:#66d9ef">int</span> i){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;W&#39;</span>) array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;B&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;W&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="翻硬币">翻硬币
</h4><p>思路同理</p>
<ul>
<li>
<p>需自己设立规则：从左往右翻，方便状态计算</p>
</li>
<li>
<p>操作同一个点多次等于没操作，则得出可<strong>依次向后操作的递推思想</strong></p>
</li>
<li>
<p>如果此点不等于该源点 则操作</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 100010,n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> g <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        String sorce <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>        String target <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> sorce.<span style="color:#a6e22e">toCharArray</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> b <span style="color:#f92672">=</span> target.<span style="color:#a6e22e">toCharArray</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> a.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> b<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                update(a,i);
</span></span><span style="display:flex;"><span>                update(a,i <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>                cnt <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(cnt);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> array,<span style="color:#66d9ef">int</span> i){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;o&#39;</span>) array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;*&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;o&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="费解的开关">费解的开关
</h4><p>思路同理：转化为二维递推</p>
<ul>
<li>在相邻的点以及同一个点操作多次都没意义，于是每一行 从左往右枚举操作</li>
<li>自己设立规则，从上往下操作，直到倒数第二行（再操作最后一行没有意义，会改变倒数第二行）</li>
<li>当最后一行不全为1则不能操作出此方案</li>
<li>枚举第一行的操作后 后面行的操作可依次递推</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 10,n,aus <span style="color:#f92672">=</span> 0x3f3f3f3f;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> g <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>5<span style="color:#f92672">][</span>5<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> ax <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span>{<span style="color:#f92672">-</span>1,0,1,0,0};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> ay <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span>{0,1,0,<span style="color:#f92672">-</span>1,0};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>((n <span style="color:#f92672">--</span>) <span style="color:#f92672">&gt;</span> 0)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//从第一行 第一列 操作 则不用管第0行 第0列的状态</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> 5;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                String s <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> 5;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    g<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> s.<span style="color:#a6e22e">charAt</span>(j) <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>                    
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(work(0x3f3f3f3f));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">work</span>(<span style="color:#66d9ef">int</span> t){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//枚举第一行的操作后(共32种操作) 后面行的操作可依次递推</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> 0;k <span style="color:#f92672">&lt;</span> (1 <span style="color:#f92672">&lt;&lt;</span> 5);k <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//用深拷贝的数组作操作 二维数组的深拷贝出错</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> backup <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>5<span style="color:#f92672">][</span>5<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> 5;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> 5;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                    backup<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> g<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0;<span style="color:#75715e">//当前枚举的步数</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//根据枚举操作第一行</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> 5;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(((k <span style="color:#f92672">&gt;&gt;</span> j) <span style="color:#f92672">&amp;</span> 1) <span style="color:#f92672">==</span> 1)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    update(0,j,backup);
</span></span><span style="display:flex;"><span>                    res <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//递推至倒数第二行</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//每次操作:如果这行数字是0 则操作下面的数字</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> 4;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> 5;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span>(backup<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        update(i <span style="color:#f92672">+</span> 1,j,backup);
</span></span><span style="display:flex;"><span>                        res <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                    }    
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> 5;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(backup<span style="color:#f92672">[</span>4<span style="color:#f92672">][</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0) 
</span></span><span style="display:flex;"><span>                    flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>               
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(flag <span style="color:#f92672">&amp;&amp;</span> res <span style="color:#f92672">&lt;</span> cnt) cnt <span style="color:#f92672">=</span> res;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(cnt <span style="color:#f92672">&gt;</span> 6) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cnt;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> y,<span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> array){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> 5;i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> ax<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> ay<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(m <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> m <span style="color:#f92672">&lt;</span> 5 <span style="color:#f92672">&amp;&amp;</span> n <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> n <span style="color:#f92672">&lt;</span> 5){
</span></span><span style="display:flex;"><span>                array<span style="color:#f92672">[</span>m<span style="color:#f92672">][</span>n<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1 <span style="color:#f92672">-</span> array<span style="color:#f92672">[</span>m<span style="color:#f92672">][</span>n<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="11模拟">11.模拟
</h3><p>字符串模拟</p>
<p>树</p>
<h2 id="2数据结构">2.数据结构
</h2><h3 id="1链表与邻接表">1.链表与邻接表
</h3><p>实现方法有：结构体指针（每次都要new node 往往都是上万级的量非常慢 算法题中可能会超时）、STL容器</p>
<h4 id="1单链表">1.单链表
</h4><p>这里用数组来模拟单链表 以head表示头节点下标 以e[ i ]表示第i个节点的值 ne[ i ]表示第i个节点的指向第几个节点 空节点表示为-1 以idx表示当前用到了哪个点 下标可以自定义从0（或1）开始（不包含头节点head 此时头节点指向0（或1））</p>
<p>具体含义 见下列代码（注意实际题目中下标可能会出现问题）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> head,e[N],ne[N],idx;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//初始化操作 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(){
</span></span><span style="display:flex;"><span>	head<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	idx<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//从0开始（不包括头节点）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//将节点插入到头节点后 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_to_head</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>    e[idx]<span style="color:#f92672">=</span>x;
</span></span><span style="display:flex;"><span>	ne[idx]<span style="color:#f92672">=</span>head;
</span></span><span style="display:flex;"><span>	head<span style="color:#f92672">=</span>idx;
</span></span><span style="display:flex;"><span>	idx<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//一般的插入操作 把值为x的节点插入到第k节点的后面 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> k){
</span></span><span style="display:flex;"><span>    e[idx]<span style="color:#f92672">=</span>x;
</span></span><span style="display:flex;"><span>	ne[idx]<span style="color:#f92672">=</span>ne[k];
</span></span><span style="display:flex;"><span>	ne[k]<span style="color:#f92672">=</span>idx;
</span></span><span style="display:flex;"><span>	idx<span style="color:#f92672">++</span>;	
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//删除第k节点后的那个节点 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>(<span style="color:#66d9ef">int</span> k){
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//这里不用考虑内存泄漏 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ne[k]<span style="color:#f92672">=</span>ne[ne[k]];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>删除头节点可表示为 head=ne[head] 具体解释可参照 数据结构（一）45:50</p>
<h4 id="2双链表">2.双链表
</h4><p>部分定义同上 记head头节点下标为0 记tail尾节点下标为1 l[N]表示左边的点 r[N]表示右边的点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> e[N],l[N],r[N],idx;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(){
</span></span><span style="display:flex;"><span>	r[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,l[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	idx<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//在第k节点的右边插入节点 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> k,<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>	e[idx]<span style="color:#f92672">=</span>x;
</span></span><span style="display:flex;"><span>	r[idx]<span style="color:#f92672">=</span>r[k];
</span></span><span style="display:flex;"><span>	l[idx]<span style="color:#f92672">=</span>k;
</span></span><span style="display:flex;"><span>	l[r[k]]<span style="color:#f92672">=</span>idx;
</span></span><span style="display:flex;"><span>	r[k]<span style="color:#f92672">=</span>idx;
</span></span><span style="display:flex;"><span>	idx<span style="color:#f92672">++</span>;	
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>(<span style="color:#66d9ef">int</span> k){
</span></span><span style="display:flex;"><span>	r[l[k]]<span style="color:#f92672">=</span>r[k];
</span></span><span style="display:flex;"><span>	l[r[k]]<span style="color:#f92672">=</span>l[k];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2栈与队列">2.栈与队列
</h3><p><strong>题型稍微会比较单一 一般涉及到暴力比较大小会超时 可考虑用单调队列 单调栈优化</strong></p>
<p>实现方法：同上</p>
<h4 id="1栈-队列">1.栈 队列
</h4><p>具体可见视频</p>
<h4 id="2单调栈-单调队列">2.单调栈 单调队列
</h4><p>思路：先用暴力 再找规律找到单调性 再优化 比如有些值永远不可能使用</p>
<p>1.单调栈</p>
<p><strong>常见模型：找出每个数最左边离它最近的比它大/小的数</strong></p>
<p><strong>本质核心：删除后的元素具有单调性，后面可用二分等操作进一步优化。避免重复计算比较 每个元素只会出栈 入栈一次</strong></p>
<p>题目描述：给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p>
<p>输入格式</p>
<p>第一行包含整数 N，表示数列长度。</p>
<p>第二行包含 N 个整数，表示整数数列。</p>
<p>输出格式</p>
<p>共一行，包含 N 个整数，其中第 i个数表示第 i个数的左边第一个比它小的数，如果不存在则输出 -1。</p>
<p>数据范围</p>
<p>1≤N≤10<!-- raw HTML omitted -->5<!-- raw HTML omitted -->
1≤数列中元素≤10<!-- raw HTML omitted -->9<!-- raw HTML omitted --></p>
<p>输入样例：</p>
<pre tabindex="0"><code>5
3 4 2 7 5
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>-1 3 -1 2 2
</code></pre><p>题目分析：可以用暴力做法 两层循环时间复杂度为O(n<!-- raw HTML omitted -->2<!-- raw HTML omitted -->)</p>
<p>简化思路：有些数字是永远不会用上 例如有以下数据 a<!-- raw HTML omitted -->1<!-- raw HTML omitted --> a<!-- raw HTML omitted -->2<!-- raw HTML omitted --> a<!-- raw HTML omitted -->3<!-- raw HTML omitted --> &hellip;..a<!-- raw HTML omitted -->i<!-- raw HTML omitted -->  以a<!-- raw HTML omitted -->i<!-- raw HTML omitted -->为中心 那么若有x&lt;y&lt;i 且a<!-- raw HTML omitted -->x<!-- raw HTML omitted --> &gt;a<!-- raw HTML omitted -->y<!-- raw HTML omitted -->以及a<!-- raw HTML omitted -->x<!-- raw HTML omitted --> , a<!-- raw HTML omitted -->y<!-- raw HTML omitted --> &lt;a<!-- raw HTML omitted -->i<!-- raw HTML omitted -->那么a<!-- raw HTML omitted -->x<!-- raw HTML omitted -->必不会被用 于是可删除a<!-- raw HTML omitted -->x <!-- raw HTML omitted --> 最终形成单调上升的数列 然后放在栈中从栈顶开始与a<!-- raw HTML omitted -->i<!-- raw HTML omitted --> 比较 如果stk[tt] &gt;= a<!-- raw HTML omitted -->i<!-- raw HTML omitted --> 那么tt-1 比较下一个直到出现比a<!-- raw HTML omitted -->i<!-- raw HTML omitted --> 小的</p>
<p>代码如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100010</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> stk[N], tt;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (tt <span style="color:#f92672">&amp;&amp;</span> stk[tt] <span style="color:#f92672">&gt;=</span> x) tt <span style="color:#f92672">--</span> ;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tt) printf(<span style="color:#e6db74">&#34;-1 &#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> printf(<span style="color:#e6db74">&#34;%d &#34;</span>, stk[tt]);
</span></span><span style="display:flex;"><span>        stk[ <span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>2.单调队列</p>
<p><strong>常见模型：滑动窗口里的最大/最小值。</strong></p>
<p><strong>本质核心：删除后的元素具有单调性，后面可用二分等操作进一步优化。避免重复计算，用单调队列来维护元素（由于需要将元素插入队尾 并将队头弹出）。</strong></p>
<p>滑动窗口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//队列存储下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">10e6</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[N],q[N];<span style="color:#75715e">//q[N]队列中存储的为下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> hh,tt <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,k;
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>k);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>) scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//判断最小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//队列不空 &amp;&amp; 如果队尾比当前点大 则不必用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(hh <span style="color:#f92672">&lt;=</span> tt <span style="color:#f92672">&amp;&amp;</span> a[q[tt]] <span style="color:#f92672">&gt;=</span> a[i]) tt <span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//队列不空 &amp;&amp; 滑出队头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(hh <span style="color:#f92672">&lt;=</span> tt <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">-</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> q[hh]) hh <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//当前i可能是最小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        q[<span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&gt;=</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) printf(<span style="color:#e6db74">&#34;%d &#34;</span>,a[q[hh]]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    puts(<span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>    hh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,tt <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(hh <span style="color:#f92672">&lt;=</span> tt <span style="color:#f92672">&amp;&amp;</span> a[q[tt]] <span style="color:#f92672">&lt;=</span> a[i]) tt <span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(hh <span style="color:#f92672">&lt;=</span> tt <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">-</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> q[hh]) hh <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        q[<span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&gt;=</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) printf(<span style="color:#e6db74">&#34;%d &#34;</span>,a[q[hh]]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3kmp">3.kmp
</h3><p>时间复杂度为0(N) 因为next数组总共最多减m次（每跳一次就最少减一次）</p>
<p>思路仍然是先暴力再考虑优化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//对于其中一个字符串 需预处理出后缀和前缀相等的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//next[i] = j的含义为[1...j] == [i-j+1...i]且j值是最大的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//next[i] = 0的含义为不存在[1...j] == [i-j+1....i] 其中j &gt;= 2故显然ne[1] = 0 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//如 &#39;aba&#39; ne[1] = 0, ne[2] = 0, ne[3] = 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100010</span>,M <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000010</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> p[N],s[M];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ne[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> p <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;&gt;</span> m <span style="color:#f92672">&gt;&gt;</span> s <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//next数组 记ne[1] = 0 求最少移动距离时的前缀点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(j <span style="color:#f92672">&amp;&amp;</span> p[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> p[i]) j <span style="color:#f92672">=</span> ne[j];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> p[i]) j <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        ne[i] <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//kmp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;=</span> m;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//j到头或者下一个点不匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(j <span style="color:#f92672">&amp;&amp;</span> p[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> s[i]) j <span style="color:#f92672">=</span> ne[j];<span style="color:#75715e">//全局观 最多减m次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(p[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> s[i]) j <span style="color:#f92672">++</span>; <span style="color:#75715e">//全局观 最多加m次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(j <span style="color:#f92672">==</span> n)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">&#34;%d &#34;</span>,i <span style="color:#f92672">-</span> n);
</span></span><span style="display:flex;"><span>            j <span style="color:#f92672">=</span> ne[n];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="4trie前缀树">4.Trie（前缀树）
</h3><p><strong>高效存储和查找字符串或可以以0、1表示的整数集合的数据结构</strong></p>
<p>时间复杂度NlogN</p>
<p>对于整数的应用可考虑 用二进制表示 0 、 1串</p>
<p>思想</p>
<ul>
<li>以一棵树来构建，则记录每一个节点的序号(参照图的表示)</li>
<li>遍历 也参照图的情况</li>
</ul>
<p><strong>Trie字符串统计</strong></p>
<p>维护一个字符串集合，支持两种操作：</p>
<ol>
<li><code>I x</code> 向集合中插入一个字符串 x；</li>
<li><code>Q </code>x 询问一个字符串在集合中出现了多少次。</li>
</ol>
<p>共有 N个操作，所有输入的字符串总长度不超过 10<!-- raw HTML omitted -->5<!-- raw HTML omitted -->，字符串仅包含小写英文字母。</p>
<p>输入格式</p>
<p>第一行包含整数 N，表示操作数。</p>
<p>接下来 N 行，每行包含一个操作指令，指令为 <code>I x</code> 或 <code>Q x</code> 中的一种。</p>
<p>输出格式</p>
<p>对于每个询问指令 <code>Q x</code>，都要输出一个整数作为结果，表示 x在集合中出现的次数。</p>
<p>每个结果占一行。</p>
<p>数据范围</p>
<p>1≤N≤2∗10<!-- raw HTML omitted -->4<!-- raw HTML omitted --></p>
<p>输入样例：</p>
<pre tabindex="0"><code>5
I abc
Q abc
Q ab
I ab
Q ab
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>1
0
1
</code></pre><p>代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//用数组存储 son[N][26] 最多有N个节点 故存储每一个节点的儿子节点</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//son[0][]第0层为根节点的儿子节点 第一层为第一个加入的节点的儿子节点~第idx层为第idx个加入的节点的儿子节点</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>iostream<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>cstring<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>algorithm<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>using namespace std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1e5 <span style="color:#f92672">+</span> 10;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> son<span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>26<span style="color:#f92672">]</span>, cnt<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>, idx;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> str<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>, op<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">char</span> str<span style="color:#f92672">[]</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> 0;<span style="color:#75715e">//从根节点开始</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;str<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> str<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>u<span style="color:#f92672">]</span>) son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>u<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>idx;<span style="color:#75715e">//如果该点的儿子节点没有对应的点则分配一个点 编号为++idx</span>
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>u<span style="color:#f92672">]</span>;<span style="color:#75715e">//走到对应的编号下 </span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cnt<span style="color:#f92672">[</span>p<span style="color:#f92672">]</span> <span style="color:#f92672">++</span>;<span style="color:#75715e">//如一个字符串加入的编号依次为 5 6 7 8 则cnt[8] ++表示第8号点为其末尾 同时idx具有唯一性</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">char</span> str<span style="color:#f92672">[]</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> 0;<span style="color:#75715e">//从根节点开始</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;str<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> str<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>u<span style="color:#f92672">]</span>) <span style="color:#66d9ef">return</span> 0;<span style="color:#75715e">//不存在</span>
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>u<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> cnt<span style="color:#f92672">[</span>p<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%s%s&#34;</span>, op, str);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>strcmp(op, <span style="color:#e6db74">&#34;I&#34;</span>))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            insert(str);
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> query(str);
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> t <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>最大异或对</strong></p>
<p>暴力做法：O(n^2)</p>
<p>暴力思路：</p>
<ul>
<li>遍历ai</li>
<li>确定ai后 再次遍历剩余的 确定ai的最大异或对</li>
</ul>
<p>优化思路：优化第二步 如果以前缀树的形式存储，则可将O(N)—&gt;O(logN) 总时间复杂度为O(NlogN)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//一颗二叉树 最多31层 </span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 100010,M <span style="color:#f92672">=</span> 31 <span style="color:#f92672">*</span> N,idx,n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> son <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>M<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            insert(arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> 0,res <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 30;j <span style="color:#f92672">&gt;=</span> 0;j <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> (arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;&gt;</span> j) <span style="color:#f92672">&amp;</span> 1;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>1 <span style="color:#f92672">-</span> m<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> 0){
</span></span><span style="display:flex;"><span>                    p <span style="color:#f92672">=</span> son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>1 <span style="color:#f92672">-</span> m<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                    res <span style="color:#f92672">+=</span> 1 <span style="color:#f92672">&lt;&lt;</span> j;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                    p <span style="color:#f92672">=</span> son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(res,ans);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(ans);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> 0;<span style="color:#75715e">//从根节点开始 son[0][m]表示根节点的儿子节点 </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 30;i <span style="color:#f92672">&gt;=</span> 0;i <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> (x <span style="color:#f92672">&gt;&gt;</span> i) <span style="color:#f92672">&amp;</span> 1;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0) son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">++</span> idx; <span style="color:#75715e">//每个节点有唯一序号</span>
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span>;<span style="color:#75715e">//走到下一个节点</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>最大异或和</strong></p>
<p>思路</p>
<ul>
<li>涉及到异或的操作：一个数异或自身等于0 可视为减去自身 于是可考虑用<strong>前缀和思想，预处理出结果</strong> 最后查询任意一段数组的异或和可在O(1)的时间复杂度内完成</li>
<li>题意转化为，si中两个数的最大异或值。</li>
<li>限制：由于含有区间限制，所以需类似于滑动窗口来维护前缀树，弹出队头，插入队尾。删除分支时，不用真正删除，用标记解决</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//一颗二叉树 最多31层 </span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 100010,M <span style="color:#f92672">=</span> 31 <span style="color:#f92672">*</span> N,idx,n,m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> son <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>M<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> cnt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>M<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        insert(0,1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            s<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a <span style="color:#f92672">^</span> s<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            insert(s<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>,1);<span style="color:#75715e">//插入队尾</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">-</span> m <span style="color:#f92672">-</span> 1 <span style="color:#f92672">&gt;=</span> 0) insert(s<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> m <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>,<span style="color:#f92672">-</span>1);<span style="color:#75715e">//删除开头</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> 0,res <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 30;j <span style="color:#f92672">&gt;=</span> 0;j <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> (s<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;&gt;</span> j) <span style="color:#f92672">&amp;</span> 1;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(cnt<span style="color:#f92672">[</span>son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>1 <span style="color:#f92672">-</span> m<span style="color:#f92672">]]</span> <span style="color:#f92672">!=</span> 0){
</span></span><span style="display:flex;"><span>                    p <span style="color:#f92672">=</span> son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>1 <span style="color:#f92672">-</span> m<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                    res <span style="color:#f92672">+=</span> 1 <span style="color:#f92672">&lt;&lt;</span> j;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                    p <span style="color:#f92672">=</span> son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(res,ans);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(ans);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> v){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> 0;<span style="color:#75715e">//从根节点开始 son[0][m]表示根节点的儿子节点 </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 30;i <span style="color:#f92672">&gt;=</span> 0;i <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> (x <span style="color:#f92672">&gt;&gt;</span> i) <span style="color:#f92672">&amp;</span> 1;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0) son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">++</span> idx; <span style="color:#75715e">//每个节点有唯一序号</span>
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> son<span style="color:#f92672">[</span>p<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span>;<span style="color:#75715e">//走到下一个节点</span>
</span></span><span style="display:flex;"><span>            cnt<span style="color:#f92672">[</span>p<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> v;<span style="color:#75715e">//标记</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="5并查集">5.并查集
</h3><p><strong>涉及到可以从集合的关系去分析问题时，可用并查集</strong></p>
<p>思路</p>
<ul>
<li>以树的形式来维护集合</li>
<li>路径压缩优化</li>
</ul>
<p>快速处理：</p>
<ol>
<li>将两个集合合并 O(1)</li>
<li>询问两个元素是否在一个集合 O(N)（递归询问祖宗节点，<strong>路径压缩后O(N)时间复杂度可视作O(1)</strong>）</li>
</ol>
<p>暴力做法： 合并O(N) 询问O(1)</p>
<p>并查集基本原理 每个集合用一棵树表示 树根的编号就是整个集合的编号 每个节点存储它的父节点  p[x] 表示x的父节点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 100010,n,m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>) p<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i;<span style="color:#75715e">//初始化 每个点的父节点是自己本身</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> m;i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            String op <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(op.<span style="color:#a6e22e">equals</span>(<span style="color:#e6db74">&#34;M&#34;</span>)) p<span style="color:#f92672">[</span>find(a)<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> find(b);<span style="color:#75715e">//将b的祖宗节点作为a的祖宗节点的父节点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(find(a) <span style="color:#f92672">==</span> find(b)) System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Yes&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;No&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//并查集的核心操作，寻找根节点祖先 + 路径压缩</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> x) p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> find(p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span>);<span style="color:#75715e">//返回父节点 直到找到root </span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//查找的过程中 路径上的点的父节点会变为根节点 ——&gt;路径压缩 O(N)的复杂度实际上可看作O(1) 下一次查询不用递归多次</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>连通块的个数</strong></p>
<p>并查集的变形：维护额外的信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> p[N], cnt[N];<span style="color:#75715e">//只有根节点才有意义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p[x] <span style="color:#f92672">!=</span> x) p[x] <span style="color:#f92672">=</span> find(p[x]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p[x];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n, m;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>) p[i] <span style="color:#f92672">=</span> i, cnt[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (m <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a, b;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> op[<span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%s&#34;</span>, op);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>strcmp(op, <span style="color:#e6db74">&#34;C&#34;</span>))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
</span></span><span style="display:flex;"><span>            a <span style="color:#f92672">=</span> find(a), b <span style="color:#f92672">=</span> find(b);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(a <span style="color:#f92672">!=</span> b)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                p[a] <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>                cnt[b] <span style="color:#f92672">+=</span> cnt[a];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>strcmp(op, <span style="color:#e6db74">&#34;Q1&#34;</span>))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(find(a) <span style="color:#f92672">==</span> find(b)) puts(<span style="color:#e6db74">&#34;Yes&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> puts(<span style="color:#e6db74">&#34;No&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>a);
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> cnt[find(a)] <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>食物链</strong></p>
<p>并查集扩展，加入路径长度</p>
<p>思路</p>
<ul>
<li>将全部节点加入一个集合，可以根据子节点到根节点的距离来分析节点之间的关系。</li>
<li>距离余1，表示可以吃根节点；距离余2，表示可以被根节点吃；距离余0，表示根节点是同类。</li>
<li>思想：没必要存每个人之间的关系，只需知道和中央的关系即可，因为可推导至和其他人的关系。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>iostream<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>using namespace std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 50010;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>, d<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//表示此节点到根节点的距离</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> x)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> find(p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>        d<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> d<span style="color:#f92672">[</span>p<span style="color:#f92672">[</span>x<span style="color:#f92672">]]</span>;<span style="color:#75715e">//更新为 此点到父节点的距离 + 此点的父节点到根节点的距离</span>
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> t; 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> ) p<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (m <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t, x, y;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>t, <span style="color:#f92672">&amp;</span>x, <span style="color:#f92672">&amp;</span>y);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//超出长度</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;</span> n <span style="color:#f92672">||</span> y <span style="color:#f92672">&gt;</span> n) res <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> px <span style="color:#f92672">=</span> find(x), py <span style="color:#f92672">=</span> find(y);<span style="color:#75715e">//先找出各自的节点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> 1)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//如果 x 和 y到根节点的距离模3不同余则不是同一类</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (px <span style="color:#f92672">==</span> py <span style="color:#f92672">&amp;&amp;</span> (d<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> d<span style="color:#f92672">[</span>y<span style="color:#f92672">]</span>) <span style="color:#f92672">%</span> 3) res <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (px <span style="color:#f92672">!=</span> py)<span style="color:#75715e">// 否则需加入集合</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    p<span style="color:#f92672">[</span>px<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> py;
</span></span><span style="display:flex;"><span>                    d<span style="color:#f92672">[</span>px<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> d<span style="color:#f92672">[</span>y<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> d<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span>;<span style="color:#75715e">//保证x 和 y 到根节点的距离是同余的</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//如果 x 和 y到根节点的距离之差减一模3不同余则是矛盾的吃关系</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (px <span style="color:#f92672">==</span> py <span style="color:#f92672">&amp;&amp;</span> (d<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> d<span style="color:#f92672">[</span>y<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> 1) <span style="color:#f92672">%</span> 3) res <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (px <span style="color:#f92672">!=</span> py)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    p<span style="color:#f92672">[</span>px<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> py;
</span></span><span style="display:flex;"><span>                    d<span style="color:#f92672">[</span>px<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> d<span style="color:#f92672">[</span>y<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 1 <span style="color:#f92672">-</span> d<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;%d\n&#34;</span>, res);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="6堆">6.堆
</h3><p>数据结构形式：完全二叉树（可用一维数组数组存储，当前为x则左节点为2x，右节点2x+1）</p>
<ul>
<li>小根堆：每个点都满足小于左右两边的点</li>
<li>大根堆：每个点都满足大于左右两边的点</li>
</ul>
<p>手写堆基本操作</p>
<ul>
<li>插入一个数：先放入末尾；up(size)</li>
<li>求最小值：小根堆取堆顶即可</li>
<li>删除最小值：将堆顶元素与末尾元素互换位置；size&ndash;（删除末尾元素）；down(1)</li>
<li>删除任意元素：将改元素与末尾元素互换位置；size&ndash;（删除末尾元素）；down(k)/up(k)</li>
<li>修改任意元素：修改；down(k)/up(k)</li>
</ul>
<p>堆排序：建堆复杂度为O(n)，排序时间复杂度O(nlogn)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100010</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h[N],len;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">up</span>(<span style="color:#66d9ef">int</span> u)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//不是堆顶 且 比父节点小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(u <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> h[u <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">&gt;</span> h[u])
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        swap(h[u],h[u <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>]);
</span></span><span style="display:flex;"><span>        u <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">down</span>(<span style="color:#66d9ef">int</span> u)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//u为该节点编号 找到该点、右节点、左节点的最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//右节点是否存在 且 右节点是否比它小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>u <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> len <span style="color:#f92672">&amp;&amp;</span> h[<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>u <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> h[t]) t <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>u <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//左节点是否存在 且 左节点是否比它小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>u <span style="color:#f92672">&lt;=</span> len <span style="color:#f92672">&amp;&amp;</span> h[<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>u] <span style="color:#f92672">&lt;</span> h[t]) t <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>u;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(t <span style="color:#f92672">!=</span> u)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        swap(h[u],h[t]);
</span></span><span style="display:flex;"><span>        down(t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>n,<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>) scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>h[i]);
</span></span><span style="display:flex;"><span>    len <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//建堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>        down(i);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(m <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//小根堆 每次取堆顶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;%d &#34;</span>,h[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//删除堆顶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        h[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> h[len];
</span></span><span style="display:flex;"><span>        len <span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        down(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="7hash表">7.Hash表
</h3><p>存储结构</p>
<ul>
<li>开放寻址法：只开一个一维数组(是原数组的2~3倍)，有冲突则一直往后找直到没有冲突为止</li>
<li>拉链法：操作：1）添加：有冲突则以链表形式存储 2）查找 3）删除，标记即可不用真正删除</li>
</ul>
<p>哈希表作用：将一个庞大的数据(0<del>10<!-- raw HTML omitted -->9<!-- raw HTML omitted -->)映射到小数据范围之间(0</del>10<!-- raw HTML omitted -->5<!-- raw HTML omitted -->)</p>
<p>开放寻址法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">200003</span>,null <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x3f3f3f3f</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//返回的是应该存储的下标位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> (x <span style="color:#f92672">%</span> N <span style="color:#f92672">+</span> N) <span style="color:#f92672">%</span> N;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//有冲突:有人且人不是x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(h[k] <span style="color:#f92672">!=</span> null <span style="color:#f92672">&amp;&amp;</span> h[k] <span style="color:#f92672">!=</span> x)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(k <span style="color:#f92672">==</span> N) k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//循环从头开始找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> k;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//memset是按字节memset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    memset(h, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span> h);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(n <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> op[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%s%d&#34;</span>,op, <span style="color:#f92672">&amp;</span>x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> find(x);<span style="color:#75715e">//找地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>strcmp(op, <span style="color:#e6db74">&#34;I&#34;</span>)) h[k] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(h[k] <span style="color:#f92672">==</span> x)
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;Yes&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> printf(<span style="color:#e6db74">&#34;No&#34;</span>);
</span></span><span style="display:flex;"><span>            puts(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>拉链法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100003</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h[N], e[N], ne[N],idx;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> (x <span style="color:#f92672">%</span> N <span style="color:#f92672">+</span> N) <span style="color:#f92672">%</span> N;
</span></span><span style="display:flex;"><span>    e[idx] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    ne[idx] <span style="color:#f92672">=</span> h[k];
</span></span><span style="display:flex;"><span>    h[k] <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span>; 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> (x <span style="color:#f92672">%</span> N <span style="color:#f92672">+</span> N) <span style="color:#f92672">%</span> N;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[k];i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(e[i] <span style="color:#f92672">==</span> x) 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n;
</span></span><span style="display:flex;"><span>    memset(h,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">sizeof</span>(h));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(n <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> op[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%s%d&#34;</span>,op, <span style="color:#f92672">&amp;</span>x);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>strcmp(op, <span style="color:#e6db74">&#34;I&#34;</span>)) insert(x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(find(x))
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;Yes&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> printf(<span style="color:#e6db74">&#34;No&#34;</span>);
</span></span><span style="display:flex;"><span>            puts(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>字符串哈希</p>
<ul>
<li>
<p>目标：求出每一个前缀的哈希值。如对于一个字符串：“abaca”则有h[0]=&ldquo;a&rdquo;，h[1]=&ldquo;ab&rdquo;，h[2]=&ldquo;aba&rdquo;，h[3]=&ldquo;abac&rdquo;,&hellip;&hellip;</p>
</li>
<li>
<p>核心：将字符串看作P进制的数，则可以将字符串转换为数字（但是可能很大需要哈希思想映射到0-p-1，这里P通常取131，模取2^64）后就可以用前缀和的思想</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//unsigned long long溢出相当于取2^64的模
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100010</span>, P <span style="color:#f92672">=</span> <span style="color:#ae81ff">131</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> str[N];
</span></span><span style="display:flex;"><span>ULL h[N], p[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ULL <span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> h[r] <span style="color:#f92672">-</span> h[l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> p[r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%s&#34;</span>, str <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    p[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        h[i] <span style="color:#f92672">=</span> h[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> P <span style="color:#f92672">+</span> str[i];
</span></span><span style="display:flex;"><span>        p[i] <span style="color:#f92672">=</span> p[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> P;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (m <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> l1, r1, l2, r2;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>l1, <span style="color:#f92672">&amp;</span>r1, <span style="color:#f92672">&amp;</span>l2, <span style="color:#f92672">&amp;</span>r2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (get(l1, r1) <span style="color:#f92672">==</span> get(l2, r2)) puts(<span style="color:#e6db74">&#34;Yes&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> puts(<span style="color:#e6db74">&#34;No&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="8stl">8.STL
</h3><p>vector</p>
<p>stack</p>
<p>queue</p>
<p>set</p>
<p>map</p>
<p>unordered_map</p>
<p>unordered_set</p>
<h2 id="3搜索与图论">3.搜索与图论
</h2><h3 id="1dfs和bfs">1.DFS和BFS
</h3><p>DFS BFS 对比</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th></th>
<th>数据结构层面</th>
<th>空间复杂度层面</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>DFS</td>
<td>stack 栈</td>
<td>O(h) h为高度</td>
<td>无最短路径概念</td>
</tr>
<tr>
<td>BFS</td>
<td>queue 队列</td>
<td>O(2<!-- raw HTML omitted -->h<!-- raw HTML omitted -->) h为高度</td>
<td>有最短路径概念</td>
</tr>
</tbody>
</table></div>
<p>求一般树的直径（找到两个点之间的边数最大）：任取一点为起点，找到里该点最远的点u(bfs，dfs都可推荐bfs不容易爆栈)。再找距离u最远的点v。uv之间即为所求。证明：u一定为最长的直径的一个端点。分情况讨论1.au与直径不相交2.au与直径相交。</p>
<p>区别：<strong>DFS回溯的时候会恢复曾经的状态。BFS由于每次经过的点都有最短路的性质（搜到的点 必为最短的 即最快到达的），所以会记录下来下次不会经过避免重复。</strong></p>
<p>共性：都能搜索，结构都是一棵树，但搜索顺序不一样。都不一定是显示的图的搜索，也有可能是状态之间的转换的搜索</p>
<h4 id="1dfs-深度优先搜索">1.DFS 深度优先搜索
</h4><p><strong>核心：</strong></p>
<ul>
<li><strong>保存路径、状态（依据题意 设计如何判断状态是否满足题意）</strong></li>
<li><strong>枚举状态时也应保证此状态是第一次重复的不然会死循环</strong></li>
<li><strong>每次回溯应恢复状态</strong></li>
</ul>
<p>对于DFS最重要的是理清搜索顺序 每个DFS一定对应一棵搜索树  不能存在环</p>
<p>回溯 剪枝</p>
<h5 id="排列数字">排列数字
</h5><p>1.问题描述</p>
<p>给定一个整数 n，将数字 1∼n排成一排，将会有很多种排列方法。</p>
<p>现在，请你按照字典序将所有的排列方法输出。</p>
<p>输入格式</p>
<p>共一行，包含一个整数 n。</p>
<p>输出格式</p>
<p>按字典序输出所有排列方案，每个方案占一行。</p>
<p>数据范围</p>
<p>1≤n≤7</p>
<p>输入样例：</p>
<pre tabindex="0"><code>3
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1 
</code></pre><p>2.问题分析</p>
<p>假设为3个数 1、2、3 写出其全排列</p>
<p>可按先第一位 确定第一位后 再第二位 确定第二位后再第3位的顺序</p>
<p>从递归结束后 回溯的时候 一定要恢复现场</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph TB
	A[XXX]--&gt;B[1XX]
	A--&gt;C[2XX]
	A--&gt;D[3XX]
	B--&gt;E[12X]
	B--&gt;F[13X]
	E--&gt;G[123]
	F--&gt;H[132]
	C--&gt;I[21X]
	C--&gt;J[23X]
	I--&gt;K[213]
	J--&gt;L[231]
	D--&gt;M[32X]
	D--&gt;N[31X]
	M--&gt;O[321]
	N--&gt;P[312]
</code></pre><p>3.代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//保存路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> path[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> st[N];<span style="color:#75715e">//true表示该数字已经用过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//u代表已有位数 最初为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//当u==n时 说明位数已经填满
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(u<span style="color:#f92672">==</span>n){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>) cout<span style="color:#f92672">&lt;&lt;</span>path[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>		printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}	
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//没用过这数字时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st[i])
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//填上数字i 并记录被用过 再往下走
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			path[u]<span style="color:#f92672">=</span>i;
</span></span><span style="display:flex;"><span>			st[i]<span style="color:#f92672">=</span>true;
</span></span><span style="display:flex;"><span>			dfs(u<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//走完后 回溯应恢复现场
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			st[i]<span style="color:#f92672">=</span>false;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	cin<span style="color:#f92672">&gt;&gt;</span>n; 
</span></span><span style="display:flex;"><span>	dfs(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="n-皇后问题">n-皇后问题
</h5><p>1.题目描述：</p>
<p>n皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现在给定整数 n，请你输出所有的满足条件的棋子摆法。</p>
<p>2.思路：从第0行开始枚举。每一行又枚举每一列。状态改变时，使用三个状态数组表示，即列，对角线，负对角线。</p>
<p>3.代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 11,n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> col <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//表示每列的状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> dg <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>2 <span style="color:#f92672">*</span> N<span style="color:#f92672">]</span>;<span style="color:#75715e">//表示正对角线状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> udg <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>2 <span style="color:#f92672">*</span> N<span style="color:#f92672">]</span>;<span style="color:#75715e">//表示负对角线状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[][]</span> ans <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//存储状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 1;j <span style="color:#f92672">&lt;=</span> n;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                ans<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>;
</span></span><span style="display:flex;"><span>        dfs(1);<span style="color:#75715e">//从第一行开始枚举</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(u <span style="color:#f92672">==</span> (n <span style="color:#f92672">+</span> 1)){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 1;j <span style="color:#f92672">&lt;=</span> n;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                     System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">print</span>(ans<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;&#34;</span>);     
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)<span style="color:#75715e">//枚举列</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>col<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>udg<span style="color:#f92672">[</span>u <span style="color:#f92672">+</span> i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>dg<span style="color:#f92672">[</span>n <span style="color:#f92672">-</span> u <span style="color:#f92672">+</span> i<span style="color:#f92672">]</span>){
</span></span><span style="display:flex;"><span>                ans<span style="color:#f92672">[</span>u<span style="color:#f92672">][</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Q&#39;</span>;
</span></span><span style="display:flex;"><span>                col<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> udg<span style="color:#f92672">[</span>u <span style="color:#f92672">+</span> i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dg<span style="color:#f92672">[</span>n <span style="color:#f92672">-</span> u <span style="color:#f92672">+</span> i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                dfs(u <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//恢复状态</span>
</span></span><span style="display:flex;"><span>                col<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> udg<span style="color:#f92672">[</span>u <span style="color:#f92672">+</span> i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dg<span style="color:#f92672">[</span>n <span style="color:#f92672">-</span> u <span style="color:#f92672">+</span> i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;<span style="color:#75715e">//还原 让同一行下一列枚举 有在这一行上的初始状态</span>
</span></span><span style="display:flex;"><span>                ans<span style="color:#f92672">[</span>u<span style="color:#f92672">][</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>;<span style="color:#75715e">//一定要还原</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="带分数">带分数
</h5><p>DFS嵌套：DFS a再DFS c。每个叶节点处 都需再次dfs</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 50, n, res;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> st <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> backup <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> c){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> b <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> (<span style="color:#66d9ef">long</span>)c <span style="color:#f92672">-</span> a <span style="color:#f92672">*</span> c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> b <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> a <span style="color:#f92672">==</span> 0) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i  <span style="color:#f92672">&lt;</span> N; i <span style="color:#f92672">++</span>) backup<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (b <span style="color:#f92672">!=</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)(b <span style="color:#f92672">%</span> 10);
</span></span><span style="display:flex;"><span>            b <span style="color:#f92672">/=</span> 10;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> backup<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            backup<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> 9; i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>backup<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs_c</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> c){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;=</span> 10) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (check(a, c)) res <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> 9; i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>){
</span></span><span style="display:flex;"><span>                st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                dfs_c(x <span style="color:#f92672">+</span> 1, a, c <span style="color:#f92672">*</span> 10 <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>                st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs_a</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> a){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">&gt;=</span> n) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">!=</span> 0) dfs_c(x, a, 0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> 9; i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>){
</span></span><span style="display:flex;"><span>                st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                dfs_a(x <span style="color:#f92672">+</span> 1, a <span style="color:#f92672">*</span> 10 <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>                st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner scan <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        dfs_a(0, 0);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>暴力做法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 20;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> n, res;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> st <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> path <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">join</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> l; i <span style="color:#f92672">&lt;=</span> r; i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            v <span style="color:#f92672">=</span> v <span style="color:#f92672">*</span> 10 <span style="color:#f92672">+</span> path<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> v;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (u <span style="color:#f92672">&gt;=</span> 10){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> 7; i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> 1; j <span style="color:#f92672">&lt;=</span> 8; j <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> join(1, i);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> join(i <span style="color:#f92672">+</span> 1, j);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> join(j <span style="color:#f92672">+</span> 1, 9);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">*</span> (<span style="color:#66d9ef">long</span>)c <span style="color:#f92672">-</span> c <span style="color:#f92672">*</span> (<span style="color:#66d9ef">long</span>)a <span style="color:#f92672">==</span> b) res <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> 9; i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>){
</span></span><span style="display:flex;"><span>                st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                path<span style="color:#f92672">[</span>u<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                dfs(u <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>                path<span style="color:#f92672">[</span>u<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>                st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner scan <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        dfs(1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="dfs剪枝优化">DFS剪枝优化
</h4><p>常用剪枝策略：</p>
<ul>
<li>优化搜索顺序：优先搜索分支较少的节点：如对于背包问题应优先选择w较大的方案这样分支较少</li>
<li>排除等效冗余：尽量不搜索重复状态：即最好以组合的形式搜索</li>
<li>可行性剪枝：提前判断不合法 提前退出</li>
<li>最优剪枝：如果当前方案不可能是最优解则退出</li>
<li>记忆化搜索（DP）</li>
</ul>
<h4 id="2bfs-宽度优先搜索">2.BFS 宽度优先搜索
</h4><p><strong>核心：1）保证每次都是第一次搜到 2）状态转换</strong></p>
<p><strong>结果必为最短路</strong>（当边权为1时）；边权为1时才能用BFS，否则使用其他专用的求最短路算法。会发现最短路类似于DP，实质上DP是特殊的最短路（DP可看作没有环路的最短路）。</p>
<p>扩展：不一定是显示的转移 也可扩展为状态转移</p>
<p>步骤：queue初始化；while(队列不空)：取队头，扩展队头。即<strong>核心是用队列维护，每一个区间为一层，即在队列中是一层挨着一层</strong></p>
<h5 id="走迷宫">走迷宫
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> PII;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">110</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> g[N][N],d[N][N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 手写队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// int bfs()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     int hh = 0,tt = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     PII q[N * N];//最多将N*N个点放入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     q[0] = {0, 0};//起点加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//     //初始化距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     memset(d, -1, sizeof d);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     d[0][0] = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//     //上下左右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//     while(hh &lt;= tt)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//         //取队头并弹出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//         auto t = q[hh ++];
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//         //每次枚举上下左右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//         for(int i = 0;i &lt; 4;i ++)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//         {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//             int x = t.first + dx[i], y= t.second + dy[i];
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//             //下一个点不越界 &amp;&amp; 能走 &amp;&amp; 一次都没有走过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//             if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//             {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//                 d[x][y] = d[t.first][t.second] + 1;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//                 q[++ tt] = {x, y};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//             }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//         }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//     return d[n - 1][m - 1];
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bfs</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span>PII<span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>    q.push({<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>});
</span></span><span style="display:flex;"><span>    memset(d, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> d);
</span></span><span style="display:flex;"><span>    d[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> dx[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}, dy[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>        q.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> t.first <span style="color:#f92672">+</span> dx[i], y<span style="color:#f92672">=</span> t.second <span style="color:#f92672">+</span> dy[i];
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//下一个点不越界 &amp;&amp; 能走 &amp;&amp; 一次都没有走过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> y <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> y <span style="color:#f92672">&lt;</span> m <span style="color:#f92672">&amp;&amp;</span> g[x][y] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> d[x][y] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                d[x][y] <span style="color:#f92672">=</span> d[t.first][t.second] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                q.push({x, y});
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;j <span style="color:#f92672">&lt;</span> m;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>g[i][j]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> bfs() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="八数码">八数码
</h5><p>将状态的转移看作宽度搜索的路径</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>iostream<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>cstring<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>algorithm<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>queue<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>unordered_map<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>using namespace std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bfs</span>(string start)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    string end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;12345678x&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//队列</span>
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//状态与转移次数的对应关系</span>
</span></span><span style="display:flex;"><span>    unordered_map<span style="color:#f92672">&lt;</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//加入起点</span>
</span></span><span style="display:flex;"><span>    q.<span style="color:#a6e22e">push</span>(start);
</span></span><span style="display:flex;"><span>    d<span style="color:#f92672">[</span>start<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> dx<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> {<span style="color:#f92672">-</span>1, 0, 1, 0}, dy<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> {0, 1, 0, <span style="color:#f92672">-</span>1};
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(q.<span style="color:#a6e22e">size</span>())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        auto t <span style="color:#f92672">=</span> q.<span style="color:#a6e22e">front</span>();
</span></span><span style="display:flex;"><span>        q.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> distance <span style="color:#f92672">=</span> d<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(t <span style="color:#f92672">==</span> end) <span style="color:#66d9ef">return</span> distance;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> t.<span style="color:#a6e22e">find</span>(<span style="color:#e6db74">&#39;x&#39;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> k <span style="color:#f92672">/</span> 3,y <span style="color:#f92672">=</span> k <span style="color:#f92672">%</span> 3;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> 4;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> dx<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>,b <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> dy<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(a <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> a <span style="color:#f92672">&lt;</span> 3 <span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">&lt;</span> 3)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//状态转移 此时t已经改变了</span>
</span></span><span style="display:flex;"><span>                swap(t<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span>,t<span style="color:#f92672">[</span>a <span style="color:#f92672">*</span> 3 <span style="color:#f92672">+</span> b<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//如果没有到过该状态才加入队列 保证BFS每次都是第一次搜到的</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>d.<span style="color:#a6e22e">count</span>(t))
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    d<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distance <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>                    q.<span style="color:#a6e22e">push</span>(t);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//由于t需转变为原来的状态 供其他转移作尝试</span>
</span></span><span style="display:flex;"><span>                swap(t<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span>,t<span style="color:#f92672">[</span>a <span style="color:#f92672">*</span> 3 <span style="color:#f92672">+</span> b<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    string start;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> 9;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> c;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> c;
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> bfs(start) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="全球变暖">全球变暖
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> x,y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Node</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> y)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1010,n,res;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[][]</span> g <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[][]</span> st <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> dx <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span>{0,<span style="color:#f92672">-</span>1,0,1},dy <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span>{1,0,<span style="color:#f92672">-</span>1,0};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            String str <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>            g<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> str.<span style="color:#a6e22e">toCharArray</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> bfs();
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bfs</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> 0,cnt <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//遍历图</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> n;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//搜到的必然是岛屿的第一个点且没有用</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(g<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cnt <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                    Queue<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//加入岛屿的第一个点</span>
</span></span><span style="display:flex;"><span>                    queue.<span style="color:#a6e22e">offer</span>(<span style="color:#66d9ef">new</span> Node(i,j));
</span></span><span style="display:flex;"><span>                    st<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">boolean</span> flag1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//遍历该岛</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>queue.<span style="color:#a6e22e">isEmpty</span>())
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">boolean</span> flag2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                        Node t <span style="color:#f92672">=</span> queue.<span style="color:#a6e22e">poll</span>();
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">//遍历上下左右</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> 0;k <span style="color:#f92672">&lt;</span> 4;k <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                        {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> t.<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> dx<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span>,y <span style="color:#f92672">=</span> t.<span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> dy<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e">//只要上下左右一面为海 则必淹没</span>
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">if</span>(g<span style="color:#f92672">[</span>x<span style="color:#f92672">][</span>y<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span> <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> y <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> y <span style="color:#f92672">&lt;</span> n) 
</span></span><span style="display:flex;"><span>                                flag2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e">//只要是陆地则走过去且没经历过 并加入该点</span>
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">if</span>(g<span style="color:#f92672">[</span>x<span style="color:#f92672">][</span>y<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;.&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>x<span style="color:#f92672">][</span>y<span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> y <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> y <span style="color:#f92672">&lt;</span> n)
</span></span><span style="display:flex;"><span>                            {
</span></span><span style="display:flex;"><span>                                queue.<span style="color:#a6e22e">offer</span>(<span style="color:#66d9ef">new</span> Node(x,y));
</span></span><span style="display:flex;"><span>                                st<span style="color:#f92672">[</span>x<span style="color:#f92672">][</span>y<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">//如果此点的上下左右都不为海则flag2为true 则此岛屿不会淹没</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span>(flag2)
</span></span><span style="display:flex;"><span>                            flag1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                        
</span></span><span style="display:flex;"><span>                           
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//此岛屿遍历完成后 如果存在</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span>(flag1) ans <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cnt <span style="color:#f92672">-</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="微博转发">微博转发
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> node,dist;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Node</span>(<span style="color:#66d9ef">int</span> node,<span style="color:#66d9ef">int</span> dist)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">node</span> <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">dist</span> <span style="color:#f92672">=</span> dist;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1010,M <span style="color:#f92672">=</span> 100 <span style="color:#f92672">*</span> N,k,idx;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> h <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>,ne <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>M<span style="color:#f92672">]</span>,e <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>M<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        Arrays.<span style="color:#a6e22e">fill</span>(h,<span style="color:#f92672">-</span>1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> cnt;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>                add(b,i);<span style="color:#75715e">//反向连接</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> q <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> q;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> bfs(m);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(res);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>        e<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> b;ne<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> h<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span>;h<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bfs</span>(<span style="color:#66d9ef">int</span> m)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> st <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        Arrays.<span style="color:#a6e22e">fill</span>(st,<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>        Queue<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        queue.<span style="color:#a6e22e">offer</span>(<span style="color:#66d9ef">new</span> Node(m,0));
</span></span><span style="display:flex;"><span>        st<span style="color:#f92672">[</span>m<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//最多遍历的深度</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>queue.<span style="color:#a6e22e">isEmpty</span>()){
</span></span><span style="display:flex;"><span>            Node x <span style="color:#f92672">=</span> queue.<span style="color:#a6e22e">poll</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> node <span style="color:#f92672">=</span> x.<span style="color:#a6e22e">node</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> dist <span style="color:#f92672">=</span> x.<span style="color:#a6e22e">dist</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(dist <span style="color:#f92672">&gt;</span> k) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//邻接矩阵的特点 每次只能遍历一层 即和其相邻的点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h<span style="color:#f92672">[</span>node<span style="color:#f92672">]</span>; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1;i <span style="color:#f92672">=</span> ne<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//取指向的点</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> e<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    st<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span>(dist <span style="color:#f92672">&lt;</span> k)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        ans <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                        queue.<span style="color:#a6e22e">offer</span>(<span style="color:#66d9ef">new</span> Node(t,dist <span style="color:#f92672">+</span> 1));
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2树与图的遍历拓扑排序">2.树与图的遍历、拓扑排序
</h3><h4 id="树">树
</h4><p>特殊的图：有向无环图</p>
<p>时间复杂度：<strong>由于在DFS和BFS中树的节点和边只会遍历一次所以树的DFS和BFS与节点数呈线性关系O(N+M)</strong></p>
<p>基本知识点</p>
<p>（1）前序、中序、后序</p>
<ul>
<li>前序：当前—&gt;左孩子—&gt;右孩子：每颗树（包括子树）都满足根节点在开头</li>
<li>中序：左孩子—&gt;当前—&gt;右孩子</li>
<li>后序：左孩子—&gt;右孩子—&gt;当前：每颗树（包括子树）都满足根节点在末尾</li>
</ul>
<p>（2）二叉树的种类</p>
<ul>
<li>满二叉树</li>
<li>完全二叉树：设编号1~n。则k号点，如果有左节点编号：2k，右节点编号为2k+1</li>
<li>二叉排序树：左子树上所有结点的关键字均小于根结点的关键字。右子树上的所有结点的关键字均大于根结点的关键字。左子树和右子树又各是一棵二叉排序树</li>
<li>平衡二叉树。树上任意一个结点的左子树和右子树的深度之差不超过1</li>
</ul>
<h5 id="树的遍历">树的遍历
</h5><ul>
<li>先会定义某个根节点 然后从根节点开始遍历 虽然是建立的是双向的图 但是会记录st数组 能够保证不会向上遍历</li>
</ul>
<p>遍历框架</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>    st[u]<span style="color:#f92672">=</span>true; <span style="color:#75715e">// 标记一下，记录为已经被搜索过了，下面进行搜索过程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>h[u];i<span style="color:#f92672">!=-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">=</span>ne[i]){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>e[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st[j]) {
</span></span><span style="display:flex;"><span>            dfs(j);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>树的重心</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//此题的核心 由上知道 每个节点只会遍历它的子树 可每次记录 每棵子树的节点数目的最大值 以及子树节点总和的数目
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//本题的本质是树的dfs， 每次dfs可以确定以u为重心的最大连通块的节点数，并且更新一下ans。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//也就是说，dfs并不直接返回答案，而是在每次更新中迭代一次答案。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//最开始是从叶节点开始更新ans
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//同时此题的题意 没有定义根节点 所以需建立双向边 这样可计算出每个点都是根节点的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//对于无向图 应开两倍的边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> h[N], e[N<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>], ne[N<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>], idx;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> st[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x3f3f3f3f</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    e[idx] <span style="color:#f92672">=</span> b,ne[idx] <span style="color:#f92672">=</span> h[a],h[a] <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    st[u] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//sum为包括它本身的所有子节点树 res为除这个点以外的连通块的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[u];i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//没有搜过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st[j])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//当前子树的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> dfs(j);
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> max(res,s);
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> s;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> max(res,n <span style="color:#f92672">-</span> sum);
</span></span><span style="display:flex;"><span>    ans <span style="color:#f92672">=</span> min(ans,res);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//初始化头节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    memset(h, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> h);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b;
</span></span><span style="display:flex;"><span>        add(a,b),add(b,a);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dfs(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//从任意一个节点开始都行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> ans <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="平衡树">平衡树
</h5><p>涉及的数据结构：</p>
<ul>
<li>BST(Binary Search Tree)：二叉搜索树：<strong>其中序遍历为从大到小的排序</strong></li>
<li>大根堆</li>
</ul>
<h4 id="图">图
</h4><ul>
<li>有向图</li>
<li>无向图：特殊的有向图，将两个端点建互相的边</li>
</ul>
<p>图的表示：邻接矩阵，十字链表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//邻接矩阵：二维数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> g[a][b]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//十字链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> h[N],<span style="color:#66d9ef">int</span> e[N],<span style="color:#66d9ef">int</span> ne[N],<span style="color:#66d9ef">int</span> idx;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//b指向a的有向边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//a——&gt;b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    e[idx] <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>    ne[idx] <span style="color:#f92672">=</span> h[a];
</span></span><span style="display:flex;"><span>    h[a] <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>图中点的层次（边权为1的最短路）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h[N], e[N], ne[N], idx;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> d[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> st[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    e[idx] <span style="color:#f92672">=</span> b, ne[idx] <span style="color:#f92672">=</span> h[a], h[a] <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bfs</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>    memset(d, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> d);
</span></span><span style="display:flex;"><span>    d[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    q.push(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(q.size())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>        q.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(t <span style="color:#f92672">==</span> n) <span style="color:#66d9ef">return</span> d[n];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[t];i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//未遍历过 则入队 改变状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st[j])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                st[j] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                d[j] <span style="color:#f92672">=</span> d[t] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                q.push(j);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    memset(h, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> h);
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> m;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b;
</span></span><span style="display:flex;"><span>        add(a, b);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> bfs() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="拓扑序列">拓扑序列
</h4><ul>
<li>有向图才有拓扑排序</li>
<li>有向无环图一定存在拓扑序列</li>
<li>一个有向无环图必存在一个入度为0的点</li>
<li>思路：先将所有入度为0的点入队 并遍历其所有边 并删除他两之间的边 即入度&ndash;。若存在环 则找不到突破口，即不存在入度为0的点</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100010</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h[N], e[N], ne[N], idx;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> d[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> q[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    e[idx] <span style="color:#f92672">=</span> b, ne[idx] <span style="color:#f92672">=</span> h[a], h[a] <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">topsort</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> hh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, tt <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//先把所有入度为0的点都找到并入队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>d[i])
</span></span><span style="display:flex;"><span>            q[ <span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (hh <span style="color:#f92672">&lt;=</span> tt)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> q[hh <span style="color:#f92672">++</span> ];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[t]; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果入度为0了则符合条件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span> d[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                q[ <span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//如果所有的边都没有进入则不存在拓扑序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> tt <span style="color:#f92672">==</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    memset(h, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> h);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a, b;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
</span></span><span style="display:flex;"><span>        add(a, b);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        d[b] <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>topsort()) puts(<span style="color:#e6db74">&#34;-1&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span> ) printf(<span style="color:#e6db74">&#34;%d &#34;</span>, q[i]);
</span></span><span style="display:flex;"><span>        puts(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3最短路">3.最短路
</h3><p>难点：转化成最短路模型 如何建图 确立边、点  下列各经典算法的证明可自行研究</p>
<p>其中对于有向图和无向图 有向图相当于为确定从a到b以及确定从b到a 而无向图相当于只确定从a到b 所以无向图可理解为特殊有向图</p>
<h4 id="1单源最短路">1.单源最短路
</h4><p>求从某点到某点的最短路。</p>
<p><strong>SPFA、dijkstra互相使用的条件</strong></p>
<h5 id="1所有边权都是正数">1.所有边权都是正数
</h5><h6 id="1朴素dijkstra">1.朴素Dijkstra
</h6><p><strong>时间复杂度：O(n<!-- raw HTML omitted -->2<!-- raw HTML omitted -->)</strong> 适用稠密图（一个图中 ，顶点数n，边数m 当n<!-- raw HTML omitted -->2<!-- raw HTML omitted -->&raquo;m时，我们称之为稀疏 当m相对较大时 我们称为稠密）</p>
<p>题目描述：给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p>
<p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p>
<p>输入格式</p>
<p>第一行包含整数 n 和 m。</p>
<p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p>
<p>输出格式</p>
<p>输出一个整数，表示 1 号点到 n 号点的最短距离。</p>
<p>如果路径不存在，则输出 −1。</p>
<p>数据范围</p>
<p>1≤n≤500,
1≤m≤10<!-- raw HTML omitted -->5<!-- raw HTML omitted -->,
图中涉及边长均不超过10000。</p>
<p>输入样例：</p>
<pre tabindex="0"><code>3 3
1 2 2
2 3 1
1 3 4
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>3
</code></pre><p>思路：记S[i]存放已经确定最短距离的点</p>
<p>步骤：</p>
<ol>
<li><strong>初始化距离 dist[i]（第i号点到起点的距离）dist[1]=0 dist[i]=+∞（其他所有点初始化为一个极大正数）</strong></li>
<li><strong>循环n次 每一次 for( i  0~n){不在S中的，距离最近的点放在T中；把T加到S中；用T更新其他点的距离（即从点t出去的距离能不能更新其他路径数据）</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//稠密图 朴素版迪杰斯特拉</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//初始化dist</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//遍历n次 共求出1号点到1~n号的最短距离</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//每次遍历都找出一个距离1号点最近的点加入已确立最短路点的集合 并通过该点来更新其他点到1号点的最新距离</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//有向图 需注意路径方向 即端点的先后关系</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>iostream<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>cstring<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>using namespace std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 510;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> g<span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dist<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>bool st<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dijkstra</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//init distance to +INF</span>
</span></span><span style="display:flex;"><span>    memset(dist, 0x3f, sizeof dist);
</span></span><span style="display:flex;"><span>    dist<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//遍历其他点 每次找到距离最近的点 并加入集合 共需遍历n次</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//t即为我们需要赋值的点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//遍历其他点 符合需求的赋值于t ——&gt;找最小值可用堆优化</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 1;j <span style="color:#f92672">&lt;=</span> n;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//当前点未加入集合 &amp;&amp; 还没有找到t（则直接赋值） || 当前t的距离不是最小的也赋值</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> (t <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1 <span style="color:#f92672">||</span> dist<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> dist<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>))
</span></span><span style="display:flex;"><span>                t <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//加入集合</span>
</span></span><span style="display:flex;"><span>        st<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//更新其他点的距离</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 1;j <span style="color:#f92672">&lt;=</span> n;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            dist<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> min(dist<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>,dist<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> g<span style="color:#f92672">[</span>t<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dist<span style="color:#f92672">[</span>n<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0x3f3f3f3f) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> dist<span style="color:#f92672">[</span>n<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
</span></span><span style="display:flex;"><span>    memset(g, 0x3f, sizeof g);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(m <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b,c;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b <span style="color:#f92672">&gt;&gt;</span> c;
</span></span><span style="display:flex;"><span>        g<span style="color:#f92672">[</span>a<span style="color:#f92672">][</span>b<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> min(g<span style="color:#f92672">[</span>a<span style="color:#f92672">][</span>b<span style="color:#f92672">]</span>,c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> dijkstra() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="2堆优化版的dijkstra">2.堆优化版的Dijkstra
</h6><p><strong>时间复杂度：O(mlogn)</strong> 适用稀疏图（一个图中 ，顶点数n，边数m 当n<!-- raw HTML omitted -->2<!-- raw HTML omitted -->&raquo;m时，我们称之为稀疏 当m相对较大时 我们称为稠密）</p>
<p>主要优化找最小的点从O(n^2)——&gt;O(mlogn)：使用数据结构堆，优先队列（用堆实现的）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> PII;<span style="color:#75715e">//dist id
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h[N],w[N],e[N],ne[N],idx;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dist[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> st[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b,<span style="color:#66d9ef">int</span> c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    e[idx] <span style="color:#f92672">=</span> b,ne[idx] <span style="color:#f92672">=</span> h[a],w[idx] <span style="color:#f92672">=</span> c,h[a] <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dijkstra</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//init distance to +INF
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    memset(dist, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span> dist);
</span></span><span style="display:flex;"><span>    dist[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//小根堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//优先队列，保证每次取出都是最小值 但是可能存在冗余
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   	<span style="color:#75715e">//维护当前未在st中标记过且离源点最近的点   小根堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//优先队列是由二叉堆来构建的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//最短距离会优先取出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    priority_queue<span style="color:#f92672">&lt;</span>PII, vector<span style="color:#f92672">&lt;</span>PII<span style="color:#f92672">&gt;</span>, greater<span style="color:#f92672">&lt;</span>PII<span style="color:#f92672">&gt;&gt;</span> heap;
</span></span><span style="display:flex;"><span>    heap.push({<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>}); <span style="color:#75715e">//加入起点 距离为0 编号为1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (heap.size())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1、找到当前未在s中出现过且离源点最近的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> heap.top();
</span></span><span style="display:flex;"><span>        heap.pop();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ver <span style="color:#f92672">=</span> t.second, distance <span style="color:#f92672">=</span> t.first;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(st[ver]) <span style="color:#66d9ef">continue</span>;<span style="color:#75715e">//冗余的点已在最小距离的集合中 直接跳过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        st[ver] <span style="color:#f92672">=</span> true;<span style="color:#75715e">//2、加入集合 并更新其他点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//3、用t更新其他点的距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[ver];i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(dist[j] <span style="color:#f92672">&gt;</span> distance <span style="color:#f92672">+</span> w[i])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                dist[j] <span style="color:#f92672">=</span> distance <span style="color:#f92672">+</span> w[i];
</span></span><span style="display:flex;"><span>                heap.push({dist[j], j});
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dist[n] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x3f3f3f3f</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> dist[n];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
</span></span><span style="display:flex;"><span>    memset(h, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> h);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(m <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b,c;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b <span style="color:#f92672">&gt;&gt;</span> c;
</span></span><span style="display:flex;"><span>        add(a,b,c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> dijkstra() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="2存在负权边">2.存在负权边
</h5><h6 id="1bellman-ford">1.Bellman-Ford
</h6><p><strong>时间复杂度：O(nm）</strong></p>
<p>思路：for循环n次 每一次循环所有边</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">/*****************伪代码*****************************/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> n次
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">备份</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#960050;background-color:#1e0010">所有边</span> a,b,w
</span></span><span style="display:flex;"><span>        dist[b]<span style="color:#f92672">=</span>min(dist[b],dist[a]<span style="color:#f92672">+</span>w);<span style="color:#75715e">//三角不等式
</span></span></span></code></pre></div><p>代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//循环n次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//每次更新m条边 遍历所有边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">510</span>,M <span style="color:#f92672">=</span> <span style="color:#ae81ff">10010</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m,k;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dist[N],last[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a,b,c;
</span></span><span style="display:flex;"><span>}edges[M];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bellman_ford</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    memset(dist, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span> dist);
</span></span><span style="display:flex;"><span>    dist[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//遍历k次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> k;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//每次需备份 深拷贝 如 可能上一次刚更新了dist[a] 但有可能会影响dist[b]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        memcpy(last, dist, <span style="color:#66d9ef">sizeof</span> dist);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//bellman更新所有边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//其实每次遍历时 如果backup[a]没有变小更新 则dist[b]一定不会被更新 所以spfa算法优化这一步
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> edges[j].a,b <span style="color:#f92672">=</span> edges[j].b,w <span style="color:#f92672">=</span> edges[j].c;
</span></span><span style="display:flex;"><span>            dist[b] <span style="color:#f92672">=</span> min(dist[b],last[a] <span style="color:#f92672">+</span> w);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m <span style="color:#f92672">&gt;&gt;</span> k;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> m;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b,w;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b <span style="color:#f92672">&gt;&gt;</span> w;
</span></span><span style="display:flex;"><span>        edges[i] <span style="color:#f92672">=</span> {a,b,w};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    bellman_ford();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dist[n] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0x3f3f3f3f</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;impossible&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> dist[n] <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="2spfa">2.SPFA
</h6><p>实际上和Bellman-ford是DP动态规划思想，区别：SPFA一定不能有负环</p>
<p><strong>时间复杂度：一般O(m) 最坏O(nm) 是对Bellman-Ford算法的优化：</strong></p>
<p>考虑到不是每次都会更新到所有边 <strong>只有当dist[a]变小dist[b]才会发生变化</strong>：使用队列（或者其他数据结构）来维护这些<strong>变小的节点a</strong>。但由于不是必须每次最短可以考虑仅使用普通Queue来维护即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//这里不需要backup数组 由于每次只更新邻边 不存在一次走多步的情况</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>iostream<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>cstring<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>queue<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>using namespace std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1e6;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>,w<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>,e<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>,ne<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>,idx;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dist<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//表示是否在队列中 已经在队列中的点重复添加没有意义</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//必须使用st数组 不然会超时</span>
</span></span><span style="display:flex;"><span>bool st<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b,<span style="color:#66d9ef">int</span> c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> b,ne<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> h<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span>,w<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> c,h<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//spfa应该不能剪枝优化 因为每次都可能会有更新</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spfa</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//init distance to +INF</span>
</span></span><span style="display:flex;"><span>    memset(dist, 0x3f, sizeof dist);
</span></span><span style="display:flex;"><span>    dist<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>    q.<span style="color:#a6e22e">push</span>(1);
</span></span><span style="display:flex;"><span>    st<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//用队列维护被更新的点 只有被更新的点 才会更新其他点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(q.<span style="color:#a6e22e">size</span>())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        auto t <span style="color:#f92672">=</span> q.<span style="color:#a6e22e">front</span>();
</span></span><span style="display:flex;"><span>        q.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        st<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span>;i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1;i <span style="color:#f92672">=</span> ne<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//只更新邻边 bellman更新的是所有边 且只把变小的点加入队列</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//可能会有重边 所以距离需更新 但是队列如果存在该点则不用加入冗余的</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//必须使用st数组 不然会超时</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(dist<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> dist<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> w<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                dist<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dist<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> w<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    q.<span style="color:#a6e22e">push</span>(j);
</span></span><span style="display:flex;"><span>                    st<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
</span></span><span style="display:flex;"><span>    memset(h, <span style="color:#f92672">-</span>1, sizeof h);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(m <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b,c;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b <span style="color:#f92672">&gt;&gt;</span> c;
</span></span><span style="display:flex;"><span>        add(a,b,c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    spfa();
</span></span><span style="display:flex;"><span>	 <span style="color:#75715e">//spfa只会更新所有能从起点走到的点，所以如果无解，那么起点就走不到终点，那么终点的距离就是0x3f3f3f3f。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dist<span style="color:#f92672">[</span>n<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0x3f3f3f3f) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;impossible&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> dist<span style="color:#f92672">[</span>n<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>判断负环</strong>：Bellman-ford和spfa均可判断，spfa时间效率更高。可计算经过某个点的边数，当边数大于等于n则认为有负环存在。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>cstring<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>iostream<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>algorithm<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>queue<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>using namespace std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 2010, M <span style="color:#f92672">=</span> 10010;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>, w<span style="color:#f92672">[</span>M<span style="color:#f92672">]</span>, e<span style="color:#f92672">[</span>M<span style="color:#f92672">]</span>, ne<span style="color:#f92672">[</span>M<span style="color:#f92672">]</span>, idx;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dist<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>, cnt<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//dist表示1-x的最短距离 cnt表示当前最短路的边数 </span>
</span></span><span style="display:flex;"><span>bool st<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> b, w<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> c, ne<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> h<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span>, h<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bool <span style="color:#a6e22e">spfa</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//不一定是从1开始有负环 需直接将所有的点加入队列</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        q.<span style="color:#a6e22e">push</span>(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (q.<span style="color:#a6e22e">size</span>())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> q.<span style="color:#a6e22e">front</span>();
</span></span><span style="display:flex;"><span>        q.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        st<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span>; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1; i <span style="color:#f92672">=</span> ne<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (dist<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> dist<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> w<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                dist<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dist<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> w<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                cnt<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> cnt<span style="color:#f92672">[</span>t<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//经历的边数大于等于n则有负环</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (cnt<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;=</span> n) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    q.<span style="color:#a6e22e">push</span>(j);
</span></span><span style="display:flex;"><span>                    st<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    memset(h, <span style="color:#f92672">-</span>1, sizeof h);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (m <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a, b, c;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b, <span style="color:#f92672">&amp;</span>c);
</span></span><span style="display:flex;"><span>        add(a, b, c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (spfa()) puts(<span style="color:#e6db74">&#34;Yes&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> puts(<span style="color:#e6db74">&#34;No&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2多源汇最短路">2.多源汇最短路
</h4><p>起点 终点多个 或起点不确定</p>
<h5 id="floyd">Floyd
</h5><p><strong>时间复杂度：O(n<!-- raw HTML omitted -->3<!-- raw HTML omitted -->)</strong></p>
<p>基于动态规划：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">210</span>, INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e9</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, m, Q;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> d[N][N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//d[k,i,j]表示从i出发只经过1-k到达j的最短距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">floyd</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;=</span> n; k <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>                d[i][j] <span style="color:#f92672">=</span> min(d[i][j], d[i][k] <span style="color:#f92672">+</span> d[k][j]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>Q);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> j) d[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> d[i][j] <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (m <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a, b, c;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b, <span style="color:#f92672">&amp;</span>c);
</span></span><span style="display:flex;"><span>        d[a][b] <span style="color:#f92672">=</span> min(d[a][b], c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    floyd();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (Q <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a, b;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> d[a][b];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">&gt;</span> INF <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) puts(<span style="color:#e6db74">&#34;impossible&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="4最小生成树">4.最小生成树
</h3><p>针对于无向图 稠密图选择朴素版Prim 稀疏图选择Kruskal算法</p>
<p>稠密图与稀疏图：数据结构中对于稀疏图的定义为：有很少条边或弧（边的条数|E|远小于|V|²）的图称为稀疏图（sparse graph），反之边的条数|E|接近|V|²，称为稠密图。<strong>简单来说边越多，图就越稠密</strong></p>
<h4 id="prim">Prim
</h4><p>分类：</p>
<ul>
<li>朴素版 O(n^2) 稠密图</li>
<li>堆优化版 O(mlogn) 稀疏图</li>
</ul>
<p>步骤：</p>
<ul>
<li>初始化所有结点</li>
<li>n次迭代：每次集合外找到离集合最近距离的<strong>点t加入集合</strong>；用t更新其他点到<strong>集合</strong>的距离</li>
</ul>
<p><strong>dijkstra是每次更新点到起点的距离</strong>；同时dijkstra是先选中某个起点 所以实际是只更新n-1次 ；prim没有起点可言，是从全局观来看总路径之和最小，其中的路径不一定是最短路。</p>
<p>朴素版Prim算法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">510</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> g[N][N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dist[N];<span style="color:#75715e">//点到集合的距离 区别于dijkstra点到起点的距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">prim</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//初始化所有距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    memset(dist, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span> dist);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//迭代n次 每次加入一个离集合最近的点 第一次由于距离都为正无穷故随机选择
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//遍历其他所有点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;j <span style="color:#f92672">&lt;=</span> n;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st[j] <span style="color:#f92672">&amp;&amp;</span> (t <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> dist[t] <span style="color:#f92672">&gt;</span> dist[j]))
</span></span><span style="display:flex;"><span>                t <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果不是第一次 且 距离是正无穷则代表不连通        
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&amp;&amp;</span> dist[t] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x3f3f3f3f</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0x3f3f3f3f</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//加入总距离 需放在更新前 因为不仅可能更新其余还未加入集合的点 还可能更新已经加入过的点 包括它自己
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(i) res <span style="color:#f92672">+=</span> dist[t];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//更新其他点到集合的距离 每次可以用此新加的点与其他点的距离比较
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;j <span style="color:#f92672">&lt;=</span> n;j <span style="color:#f92672">++</span>) dist[j] <span style="color:#f92672">=</span> min(dist[j],g[t][j]);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        st[t] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
</span></span><span style="display:flex;"><span>    memset(g, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span> g);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (m <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b,c;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b <span style="color:#f92672">&gt;&gt;</span> c;
</span></span><span style="display:flex;"><span>        g[a][b] <span style="color:#f92672">=</span> g[b][a] <span style="color:#f92672">=</span> min(g[a][b],c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> prim();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(t <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x3f3f3f3f</span>) puts(<span style="color:#e6db74">&#34;impossible&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> printf(<span style="color:#e6db74">&#34;%d&#34;</span>,t);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>堆优化版Prim算法O(mlogn) 但是往往kruskal更好</p>
<p>用优先队列维护dist数组</p>
<h4 id="kruskal">Kruskal
</h4><p>时间复杂度：O(mlogm)。</p>
<p>步骤</p>
<ul>
<li>将所有边按权重<strong>从小到大排序</strong>。快排O(mlogm)。</li>
<li>枚举每条边a b。如果a b不连通（并查集查询O(1)），则把<strong>边加入集合</strong>。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>iostream<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>cstring<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#f92672">&lt;</span>algorithm<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>using namespace std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 2e5 <span style="color:#f92672">+</span> 10;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//并查集</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>struct Edge
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a,b,w;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    bool operator<span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> Edge <span style="color:#f92672">&amp;</span>edge)<span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> w <span style="color:#f92672">&lt;</span> edge.<span style="color:#a6e22e">w</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}edges<span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> x) p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> find(p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b,w;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b <span style="color:#f92672">&gt;&gt;</span> w;
</span></span><span style="display:flex;"><span>        edges<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> {a,b,w};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//排序</span>
</span></span><span style="display:flex;"><span>    sort(edges, edges <span style="color:#f92672">+</span> m);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//初始化并查集</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>) p<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0,cnt <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//遍历所有边</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> m;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> edges<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>.<span style="color:#a6e22e">a</span>, b <span style="color:#f92672">=</span> edges<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>.<span style="color:#a6e22e">b</span>, w <span style="color:#f92672">=</span> edges<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>.<span style="color:#a6e22e">w</span>;
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> find(a), b <span style="color:#f92672">=</span> find(b);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果不连通 则合并集合 并加入边</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(a <span style="color:#f92672">!=</span> b)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">+=</span> w;
</span></span><span style="display:flex;"><span>            cnt <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//如果边数小于n - 1则 表明点未加完 </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(cnt <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> 1) puts(<span style="color:#e6db74">&#34;impossible&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> printf(<span style="color:#e6db74">&#34;%d&#34;</span>,res);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="5二分图">5.二分图
</h3><p><strong>当且仅当图中不含奇数环（指某个环的边数为奇数）。二分图通常针对 无向图 问题（有些题目虽然是有向图，但一样有二分图性质）在一张图中，如果能够把全部的点分到 两个集合 中，保证两个集合内部没有 任何边 ，图中的边 只存在于两个集合之间，这张图就是二分图</strong></p>
<h4 id="染色法">染色法
</h4><p>O(n + m)：树dfs的时间复杂度</p>
<p>由于二分图的集合内部不能有边，则可考虑遍历点 先随机染色某个点为黑 然后和其相连的点染白（<strong>根据定义边只存在于对立集合 不存在于内部集合</strong>），这样通过dfs/bfs遍历下去，如果没有矛盾即一个点不可能既是黑又是白，则为二分图。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h[N], e[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> N], ne[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> N], idx;<span style="color:#75715e">//无向图边的数量需翻倍
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> color[N];<span style="color:#75715e">//0为还未蓝色 其余两种颜色为 1、2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)  <span style="color:#75715e">// 添加一条边a-&gt;b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    e[idx] <span style="color:#f92672">=</span> b, ne[idx] <span style="color:#f92672">=</span> h[a], h[a] <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//u为点 c为颜色
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u,<span style="color:#66d9ef">int</span> c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    color[u] <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//dfs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[u];i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果还未染色 且过程中也会矛盾 也返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>color[j])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfs(j, <span style="color:#ae81ff">3</span> <span style="color:#f92672">-</span> c)) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果已经染过色且颜色已经和领点一样 则直接返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(color[j] <span style="color:#f92672">==</span> c) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    memset(h, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> h);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (m <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a, b;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
</span></span><span style="display:flex;"><span>        add(a, b),add(b, a);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> flag <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果未染色 则染色
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>color[i])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfs(i, <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                flag <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;    
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(flag) puts(<span style="color:#e6db74">&#34;Yes&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> puts(<span style="color:#e6db74">&#34;No&#34;</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="匈牙利算法">匈牙利算法
</h4><p>时间复杂度：O(mn)。返回二分图的最大匹配（匹配指没有两条边共有点）的个数。</p>
<p>具体证明可参考算法导论</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">510</span>, M <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h[N], e[M], ne[M], idx;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> match[N];<span style="color:#75715e">//右集合所对应的左集合中的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n1, n2, m;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)  <span style="color:#75715e">// 添加一条边a-&gt;b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    e[idx] <span style="color:#f92672">=</span> b, ne[idx] <span style="color:#f92672">=</span> h[a], h[a] <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//每一次遍历一遍传进来的左边集合x对应的右边集合中的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[x];i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 判断这个点是不是已经用过了，没用过继续
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st[j])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            st[j] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//这里st的作用大致就是递归时候起到判重的作用，因为下一位男生遍历时候一开始都会将st初始化为false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>           	<span style="color:#75715e">//然后将这个点标记为有了，然后如果刚好标记之后这个位置的女生已经被上一个男生约定俗成了，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>           	<span style="color:#75715e">//就递归看看这个男生是不是还有其他可以喜欢的女生，这个时候判重的作用就体现了，因为在这个过程中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>           	<span style="color:#75715e">//st已经被true标记了，所以上一个男生重新遍历时候遍历到这个女生就知道要让给下一个男生，所以找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//自己的其他中意的女生，然后将自己与另外以为女生绑定，如果没有其他喜欢的女生，就返回flase，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//然后下一个男生就是单生，或者看看自己还有没有其他喜欢的女生，以此类推，得出最完美结果！！！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>match[j] <span style="color:#f92672">||</span> find(match[j]))
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                match[j] <span style="color:#f92672">=</span> x;<span style="color:#75715e">//match是表示女生对应的男生是谁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n1 <span style="color:#f92672">&gt;&gt;</span> n2 <span style="color:#f92672">&gt;&gt;</span> m;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    memset(h, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> h);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> m;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a, b;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b;
</span></span><span style="display:flex;"><span>        add(a, b);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//统计最大匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//遍历一下所有左半边集合的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&lt;=</span> n1;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//每一次模拟都要将st数组清空,这个判断重复的点,match是物有所主了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//st数组用来保证本次匹配过程中，右边集合中的每个点只被遍历一次，防止死循环。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//match存的是右边集合中的每个点当前匹配的点是哪个，但就算某个点当前已经匹配了某个点，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//也有可能被再次遍历，所以不能起到判重的作用。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        memset(st, false, <span style="color:#66d9ef">sizeof</span> st);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(find(i)) res <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> res <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="4数学知识">4.数学知识
</h2><p>主要是一些公式转化，将一道复杂的问题转化为公式。以及一些常用公式的应用和演算。</p>
<h3 id="1质数">1.质数
</h3><h4 id="质数的判定">质数的判定
</h4><p>——试除法 (时间复杂度必为O(sqrt(N)))</p>
<p>for(int i = 2;i&lt;n;i++) if(n%i == 0) return;时间复杂度为O(N)</p>
<p>试除法优化for(int i = 2;i&lt;=n/i;i++) return;时间复杂度为O(sqrt(N))</p>
<h4 id="分解质因数">分解质因数
</h4><p>质数的判定——试除法</p>
<p>可以考虑枚举从2~N的所有数 没枚举一个 若能整除 则直到将其整除干净为止 容易TLE</p>
<p>优化 思路：一个数最多有一个大于sqrt(N)的质数 （若有两个大于sqrt(N)的质数 则其二者相乘大于N 矛盾）</p>
<p>则只需让i枚举到sqrt(N)即可 最后判断剩余的数是否大于1即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">divide</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 2; i <span style="color:#f92672">&lt;=</span> n<span style="color:#f92672">/</span>i ; i<span style="color:#f92672">++</span>){<span style="color:#75715e">//i * i容易溢出</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>( n <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>                s<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                n<span style="color:#f92672">/=</span> i;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>( s <span style="color:#f92672">!=</span> 0) System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(i<span style="color:#f92672">+</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">+</span>s);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">&gt;</span> 1)  System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(n<span style="color:#f92672">+</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">+</span>1);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>时间复杂度为最坏O(sqrt(N))最好O(logN)（当N = 2<!-- raw HTML omitted -->k<!-- raw HTML omitted -->）</p>
<h4 id="筛质数">筛质数
</h4><p>——从1~N筛选出质数</p>
<p>首先考虑逐个划去各个数的倍数对于2划去4、6、8&hellip;对于3划去6、9、12&hellip;对于4划去8、12、16&hellip;剩下的即为质数</p>
<p>循环次数为 (N/2+N/3+N/4+&hellip;+N/N)当N—&gt;+∞ （1+N/2+N/3+N/4+&hellip;+N/N）—&gt;ln(N+1)+e</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//埃式筛法 时间复杂度O(N)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1000010,n,cnt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> st <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//此下标是否为质数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> primes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//存质数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(get_prime(n));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_prime</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 2;i <span style="color:#f92672">&lt;=</span> x;i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>){<span style="color:#75715e">//如果是false 则必然是质数 因为合数在前面一定被全部筛掉了</span>
</span></span><span style="display:flex;"><span>                st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> i;j <span style="color:#f92672">&lt;=</span> x;j <span style="color:#f92672">+=</span> i) st<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;<span style="color:#75715e">//每次只筛出质数的倍数 不考虑合数的倍数</span>
</span></span><span style="display:flex;"><span>                res <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//线性筛法 保证每个数都被其最小质因子筛掉</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_prime</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 2;i <span style="color:#f92672">&lt;=</span> x;i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>) primes<span style="color:#f92672">[</span>cnt <span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> i;<span style="color:#75715e">//如果是false 则必然是质数 因为合数在前面一定被全部筛掉了</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//从小到大遍历所有质数</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;primes<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;=</span> n <span style="color:#f92672">/</span> i;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            st<span style="color:#f92672">[</span>primes<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//此优化一定加上</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">%</span> primes<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0) <span style="color:#66d9ef">break</span>;<span style="color:#75715e">//此条件成立时 primes[j]一定是i的最小质因子或者遍历到质数自身便弹出</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cnt;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或者 这样也可以？</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1000010,n,cnt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> primes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> st <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> get_primes(n);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(cnt);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_primes</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 2;i <span style="color:#f92672">&lt;=</span> x;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>) primes<span style="color:#f92672">[</span>cnt <span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> i; 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 2;j <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">/</span> i;j <span style="color:#f92672">++</span>) st<span style="color:#f92672">[</span>j <span style="color:#f92672">*</span> i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cnt;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2约数">2.约数
</h3><h4 id="确定所有约数">确定所有约数
</h4><p>——试除法O(sqrt(N))</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get_divisors</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>(); <span style="color:#75715e">// 创建一个list容器存放每一个约数</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1 ; i <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">/</span> i ; i <span style="color:#f92672">++</span> ){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>                list.<span style="color:#a6e22e">add</span>(i);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//这里特判一下，因为约数有可能是两个约数相同，比如4*4,5*5,它本只有一个约数，所以就要特判一下</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">!=</span> x <span style="color:#f92672">/</span> i ) list.<span style="color:#a6e22e">add</span>(x <span style="color:#f92672">/</span> i);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Collections.<span style="color:#a6e22e">sort</span>(list);<span style="color:#75715e">//排序从小到大</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//增强for循环</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//冒号左边是类型，右边是数组或者集合</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i : list){
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">print</span>(i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner scan <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(n <span style="color:#f92672">--</span> <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            get_divisors(a);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="约数个数">约数个数
</h4><p>记N = p1<!-- raw HTML omitted -->a1<!-- raw HTML omitted --> * p2<!-- raw HTML omitted -->a2<!-- raw HTML omitted -->* &hellip;  pk<!-- raw HTML omitted -->ak<!-- raw HTML omitted --></p>
<p>则N的约数个数为（a1 + 1）*（a2 + 1） * &hellip; (ak + 1)。因为每一个约数只取0次方到ai次方</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 基本思想 </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//如果 N = p1^c1 * p2^c2 * ... *pk^ck</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> mod <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)1e9 <span style="color:#f92672">+</span> 7;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Map<span style="color:#f92672">&lt;</span>Integer,Integer<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;</span>(); <span style="color:#75715e">//创建一个哈希表</span>
</span></span><span style="display:flex;"><span>        Scanner scan <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(n <span style="color:#f92672">--</span> <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//下面这里是运用了分解质因数的模板，</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 2 ; i <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">/</span> i ; i <span style="color:#f92672">++</span> ){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span>(x <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>                    x <span style="color:#f92672">/=</span> i;
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// map.getOrDefault(i,0) 这个是获取对应i位置的values值</span>
</span></span><span style="display:flex;"><span>                    map.<span style="color:#a6e22e">put</span>(i,map.<span style="color:#a6e22e">getOrDefault</span>(i,0) <span style="color:#f92672">+</span> 1); 
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&gt;</span> 1) map.<span style="color:#a6e22e">put</span>(x,map.<span style="color:#a6e22e">getOrDefault</span>(x,0)  <span style="color:#f92672">+</span> 1 );
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//map.keySet()获取所有的key值,map.values()获取所有的values值，两种方法都可以</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> key : map.<span style="color:#a6e22e">values</span>()){
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> (key <span style="color:#f92672">+</span> 1) <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="约数之和">约数之和
</h4><p>记N = p1<!-- raw HTML omitted -->a1<!-- raw HTML omitted --> * p2<!-- raw HTML omitted -->a2<!-- raw HTML omitted -->* &hellip;  pk<!-- raw HTML omitted -->ak<!-- raw HTML omitted --></p>
<p>则N的约数之和(p1^0 + p1^1 + p1^2 + &hellip;) * (p2^0 + p2^1 + p2^2 + &hellip;) * &hellip;. ()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> mod <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)1e9 <span style="color:#f92672">+</span> 7;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner scan <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        Map<span style="color:#f92672">&lt;</span>Integer,Integer<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(n <span style="color:#f92672">--</span> <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> x  <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 2 ; i <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">/</span> i ; i <span style="color:#f92672">++</span> ){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span>(x <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>                    x <span style="color:#f92672">/=</span> i;
</span></span><span style="display:flex;"><span>                    map.<span style="color:#a6e22e">put</span>(i,map.<span style="color:#a6e22e">getOrDefault</span>(i,0) <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&gt;</span> 1) map.<span style="color:#a6e22e">put</span>(x,map.<span style="color:#a6e22e">getOrDefault</span>(x,0) <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> a : map.<span style="color:#a6e22e">keySet</span>()){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//int a = map.getKey();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> map.<span style="color:#a6e22e">get</span>(a);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> t <span style="color:#f92672">=</span> 1; 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//秦九韶算法</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//这里为什么是t * a + 1,后面的一是我们将没有将t等于0，所以我们自己将a的0次方写成1，方便代码表达</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(b <span style="color:#f92672">--</span> <span style="color:#f92672">&gt;</span> 0) t <span style="color:#f92672">=</span> (t <span style="color:#f92672">*</span> a <span style="color:#f92672">+</span> 1) <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">/</span>求约数之和就是分解质因数之后<span style="color:#960050;background-color:#1e0010">，</span>将每一个质因数的质数从0到最大进行罗列相加<span style="color:#960050;background-color:#1e0010">，</span>最后所有质数的罗列相乘
</span></span><span style="display:flex;"><span>           <span style="color:#75715e">// p = a ^ 3 * b ^ 1;</span>
</span></span><span style="display:flex;"><span>           <span style="color:#75715e">// sum = (a ^ 0 + a ^ 1 + a ^ 2 + a ^ 3) * (b ^ 0 + b ^ 1)</span>
</span></span><span style="display:flex;"><span>           <span style="color:#75715e">// 这个结果就是我们想要求得约数之和</span>
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> t <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="最大公约数">最大公约数
</h4><p>——欧几里得算法（辗转相除法）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(i <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(gcd(a,b));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//欧几里得算法 辗转相除法 求最大公约数 核心公式(a,b) = (b,a mod b)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">gcd</span>(<span style="color:#66d9ef">int</span> i,<span style="color:#66d9ef">int</span> j){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(j <span style="color:#f92672">!=</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> gcd(j, i <span style="color:#f92672">%</span> j);
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3欧拉函数">3.欧拉函数
</h3><p>欧拉函数定义：求1~N中与N互质的个数（包括1 如6互质数为1、5） 与质因子的次数没有关系。
$$
N=p_1^{a_1}p_2^{a_2}&hellip;p_m^{a_m}\
\phi(N)=N×\frac{p_1-1}{p_1} ×\frac{p_2-1}{p_2}&hellip; ×\frac{p_m-1}{p_m}
$$
代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//试除法 时间复杂度sqrt(N)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc  <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(a <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>            a<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(cnt(i));   
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cnt</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 2; i <span style="color:#f92672">&lt;=</span> n<span style="color:#f92672">/</span>i; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">%</span>i <span style="color:#f92672">==</span> 0) res <span style="color:#f92672">=</span> res<span style="color:#f92672">/</span>i <span style="color:#f92672">*</span>(i <span style="color:#f92672">-</span> 1);<span style="color:#75715e">//试除法 求质因子 同时计算欧拉函数公式</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(n<span style="color:#f92672">%</span>i <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>                n<span style="color:#f92672">/=</span>i;<span style="color:#75715e">//除干净</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>( n <span style="color:#f92672">&gt;</span> 1 ) res <span style="color:#f92672">=</span> res<span style="color:#f92672">/</span>n<span style="color:#f92672">*</span>(n<span style="color:#f92672">-</span>1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//参考线性筛法 筛欧拉函数</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1000010,n,cnt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> primes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> phi <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//存储每个数的欧拉函数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> st <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> get_euler(n);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">get_euler</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        phi<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 2;i <span style="color:#f92672">&lt;=</span> x;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                primes<span style="color:#f92672">[</span>cnt <span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                phi<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> 1;<span style="color:#75715e">//i为质数 在1~i中共有i-1个与i互质的数</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//遍历现有的质数</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;primes<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">/</span> i;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                st<span style="color:#f92672">[</span>primes<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//i 和 primes[j]互质 则 primes[j] 必为 primes[j] * i的质因子 </span>
</span></span><span style="display:flex;"><span>                phi<span style="color:#f92672">[</span>primes<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> phi<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> (primes<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">%</span> primes<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//primes[j] 必为 i的最小质因子</span>
</span></span><span style="display:flex;"><span>                    phi<span style="color:#f92672">[</span>primes<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> phi<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> primes<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">+=</span> phi<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>欧拉定理</strong>
$$
若a与n互质\space则有a^{\phi(n)} mod(n)=1
$$
<strong>费马定理</strong>：欧拉函数的变形
$$
若p是质数\space且a与p互质\space则有a^{p-1}mod(p)=1
$$</p>
<h3 id="4快速幂">4.快速幂
</h3><p>已知a,b,p均≤2×10<!-- raw HTML omitted -->9<!-- raw HTML omitted -->  求a<!-- raw HTML omitted -->b<!-- raw HTML omitted --> 除p的余数 暴力求解 循环b次 超时且超出大小 这里考虑将b以2进制的方式写出 如（1101）<!-- raw HTML omitted -->2<!-- raw HTML omitted --></p>
<p>a<!-- raw HTML omitted -->b<!-- raw HTML omitted --> = a * a<!-- raw HTML omitted -->2<!-- raw HTML omitted -->2<!-- raw HTML omitted --><!-- raw HTML omitted --> * a<!-- raw HTML omitted -->2<!-- raw HTML omitted -->3<!-- raw HTML omitted --><!-- raw HTML omitted --> 这里将时间复杂度优化为 <strong>O(k)—&gt;O(logk)</strong></p>
<p>快速幂模板</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">quickmod</span>(<span style="color:#66d9ef">long</span> a,<span style="color:#66d9ef">long</span> b,<span style="color:#66d9ef">long</span> p){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(b <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>((b <span style="color:#f92672">&amp;</span> 1) <span style="color:#f92672">==</span> 1) res <span style="color:#f92672">=</span> (res <span style="color:#f92672">*</span> a) <span style="color:#f92672">%</span> p;<span style="color:#75715e">//以b的2进制方式</span>
</span></span><span style="display:flex;"><span>            b <span style="color:#f92672">=</span> b <span style="color:#f92672">&gt;&gt;</span> 1;
</span></span><span style="display:flex;"><span>            a <span style="color:#f92672">=</span> (a <span style="color:#f92672">*</span> a) <span style="color:#f92672">%</span> p; <span style="color:#75715e">//依次为a a^2 a^4 a^8 a^16...</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>应用：快速幂求逆元</p>
<p>给定 n 组 ai,pi，其中 pi 是质数，求 ai 模 pi 的乘法逆元，若逆元不存在则输出 <code>impossible</code>。</p>
<p>注意：请返回在 0∼p−1 之间的逆元。</p>
<p>乘法逆元的定义</p>
<blockquote>
<p>若整数 b，m互质，并且对于任意的整数 a，如果满足 b|a，则存在一个整数 x，使得 a/b≡a×x(mod m），则称 x 为 b 的模 m 乘法逆元，记为 b<!-- raw HTML omitted -->−1<!-- raw HTML omitted -->(mod m)。
b 存在乘法逆元的充要条件是 b 与模数 m 互质。当模数 m 为质数时，b<!-- raw HTML omitted -->m−2<!-- raw HTML omitted --> 即为 b 的乘法逆元。</p>
</blockquote>
<p>输入格式</p>
<p>第一行包含整数 n。</p>
<p>接下来 n 行，每行包含一个数组 ai,pi，数据保证 pi是质数。</p>
<p>输出格式</p>
<p>输出共 n 行，每组数据输出一个结果，每个结果占一行。</p>
<p>若 ai 模 pi 的乘法逆元存在，则输出一个整数，表示逆元，否则输出 <code>impossible</code>。</p>
<p>数据范围</p>
<p>1≤n≤10<!-- raw HTML omitted -->5<!-- raw HTML omitted -->
1≤ai,pi≤2∗10<!-- raw HTML omitted -->9<!-- raw HTML omitted --></p>
<p>输入样例：</p>
<pre tabindex="0"><code>3
4 3
8 5
6 3
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>1
2
impossible
</code></pre><p>思路：<strong>费马小定理 如果p是一个质数，而整数a不是p的倍数，则有a<!-- raw HTML omitted -->p-1<!-- raw HTML omitted --> ≡ 1（mod p）</strong></p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(n <span style="color:#f92672">&gt;</span> 0)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> a <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextLong</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> p <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextLong</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>((a <span style="color:#f92672">%</span> p) <span style="color:#f92672">==</span> 0) System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;impossible&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> quickmod(a,p);
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(res);   
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">quickmod</span>(<span style="color:#66d9ef">long</span> a,<span style="color:#66d9ef">long</span> p){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)1,b <span style="color:#f92672">=</span> p <span style="color:#f92672">-</span> (<span style="color:#66d9ef">long</span>)2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(b <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>((b <span style="color:#f92672">&amp;</span> 1) <span style="color:#f92672">==</span> 1) res <span style="color:#f92672">=</span> (res <span style="color:#f92672">*</span> a) <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>            b <span style="color:#f92672">=</span> b <span style="color:#f92672">&gt;&gt;</span> 1;
</span></span><span style="display:flex;"><span>            a <span style="color:#f92672">=</span> (a <span style="color:#f92672">*</span> a) <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="5扩展欧几里得算法">5.扩展欧几里得算法
</h3><p><strong>裴蜀定理</strong>
$$
对任意正整数a、b，一定存在整数x、y，使得\space ax +by=(a,b)\
当a、b互质时，有ax+by=1
$$
<strong>扩展欧几里得算法</strong></p>
<p>给定 n 对正整数 ai,bi，对于每对数，求出一组 xi,yi，使其满足 ai×xi+bi×yi=gcd(ai,bi)</p>
<p>输入格式</p>
<p>第一行包含整数 n。</p>
<p>接下来 n行，每行包含两个整数 ai,bi。</p>
<p>输出格式</p>
<p>输出共 n 行，对于每组 ai,bi求出一组满足条件的 xi,yi，每组结果占一行。</p>
<p>本题答案不唯一，输出任意满足条件的 xi,yi 均可。</p>
<p>数据范围</p>
<p>1≤n≤10^5,
1≤ai,bi≤2×10^9</p>
<p>输入样例：</p>
<pre tabindex="0"><code>2
4 6
8 18
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>-1 1
-2 1
</code></pre><p>代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> x <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span>{0},y <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span>{0};
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            exgcd(a,b,x,y);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(x<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> y<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">exgcd</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b,<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> x,<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> y){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(b <span style="color:#f92672">==</span> 0)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            x<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1;y<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> exgcd(b,a <span style="color:#f92672">%</span> b,y,x);
</span></span><span style="display:flex;"><span>        y<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">-=</span> (a <span style="color:#f92672">/</span> b) <span style="color:#f92672">*</span> x<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="6中国剩余定理">6.中国剩余定理
</h3><p>中国剩余定理</p>
<p><img src="C:%5cUsers%5cwcx%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20230405124028693.png"
	
	
	
	loading="lazy"
	
		alt="image-20230405124028693"
	
	
></p>
<p>推导，以两个方程为例子
$$
xmod(a_1)=m1;xmod(a_2)=m2\
转化为等式\space x=k1<em>a1+m1;x=k2</em>a2+m2\
k1<em>a1-k2</em>a2=m2-m1\
由裴蜀定理:k1、k2有无数解,通解为k1=k1+k<em>a2/d;k2=k2+k</em>a1/d;d=(a1,a2)\
代入原式得\space x=k1<em>a1+m+k</em>a1<em>a2/d=k1</em>a1+m+k*[a1,a2]=m0+k*a0 （递推下去）
$$</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">boolean</span> ans <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> a1 <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextLong</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> m1 <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextLong</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span><span style="color:#f92672">[]</span> k1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">[]</span>{0};
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(n <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> a2 <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextLong</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> m2 <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextLong</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span><span style="color:#f92672">[]</span> k2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">[]</span>{0};
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> d <span style="color:#f92672">=</span> exgcd(a1,a2,k1,k2);<span style="color:#75715e">//扩展欧几里得求k1 k2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(((m2 <span style="color:#f92672">-</span> m1) <span style="color:#f92672">%</span> d) <span style="color:#f92672">!=</span> 0)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                ans <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            k1<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span>(m2 <span style="color:#f92672">-</span> m1) <span style="color:#f92672">/</span> d <span style="color:#f92672">*</span> k1<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>; <span style="color:#75715e">//翻倍 求出的是通解的某一解即k1=k1+k*a2/d</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> t <span style="color:#f92672">=</span> a2 <span style="color:#f92672">/</span> d;
</span></span><span style="display:flex;"><span>            k1<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> (k1<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">%</span> t <span style="color:#f92672">+</span> t) <span style="color:#f92672">%</span> t;<span style="color:#75715e">//取a2/d的模</span>
</span></span><span style="display:flex;"><span>            m1 <span style="color:#f92672">=</span> a1 <span style="color:#f92672">*</span> k1<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> m1;<span style="color:#75715e">//递推</span>
</span></span><span style="display:flex;"><span>            a1 <span style="color:#f92672">=</span> (a1 <span style="color:#f92672">*</span> a2) <span style="color:#f92672">/</span> d;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(ans) System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(m1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#f92672">-</span>1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">exgcd</span>(<span style="color:#66d9ef">long</span> a,<span style="color:#66d9ef">long</span> b,<span style="color:#66d9ef">long</span> x<span style="color:#f92672">[]</span>,<span style="color:#66d9ef">long</span> y<span style="color:#f92672">[]</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(b <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>            x<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>            y<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> d <span style="color:#f92672">=</span> exgcd(b,a <span style="color:#f92672">%</span> b,y,x);
</span></span><span style="display:flex;"><span>        y<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">-=</span> (a <span style="color:#f92672">/</span> b) <span style="color:#f92672">*</span> x<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> d;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="7高斯消元">7.高斯消元
</h3><p>有唯一解 有无数解 无解 知识内容参考线代知识</p>
<h3 id="8组合计数">8.组合计数
</h3><p><strong>组合1</strong>
$$
C_a^b = C_{a-1}^{b-1}+C_{a-1}^b
$$</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//公式Ca^b = Ca-1^b + Ca-1^b-1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//计算量2000 递推预处理所有结果 时间复杂度O(N^2)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 2010,mod <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)1e9 <span style="color:#f92672">+</span> 7;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> c <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        init();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(c<span style="color:#f92672">[</span>a<span style="color:#f92672">][</span>b<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> N;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;=</span> i;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(j <span style="color:#f92672">==</span> 0) c<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> c<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> (c<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> c<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>) <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>组合2</strong></p>
<p>不直接用阶乘的形式预处理 因为有相除 莫完余数后不一定整除 如果不摸 会超。参照快速幂求逆元(<strong>费马小定理前提：互质</strong>)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//预处里复杂度O(nlogk)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 100010,n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> mod <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)1e9 <span style="color:#f92672">+</span> (<span style="color:#66d9ef">long</span>)7;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">[]</span> frac <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>,infrac <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> N;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>                infrac<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> frac<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)1;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            frac<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> frac<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> (<span style="color:#66d9ef">long</span>)i <span style="color:#f92672">%</span> mod; 
</span></span><span style="display:flex;"><span>            infrac<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> infrac<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> qml((<span style="color:#66d9ef">long</span>)i,mod <span style="color:#f92672">-</span> (<span style="color:#66d9ef">long</span>)2,mod) <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> ans <span style="color:#f92672">=</span> (frac<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span> <span style="color:#f92672">*</span> infrac<span style="color:#f92672">[</span>b<span style="color:#f92672">]</span> <span style="color:#f92672">%</span> mod <span style="color:#f92672">*</span> infrac<span style="color:#f92672">[</span>a <span style="color:#f92672">-</span> b<span style="color:#f92672">]</span>) <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(ans);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">qml</span>(<span style="color:#66d9ef">long</span> a,<span style="color:#66d9ef">long</span> b,<span style="color:#66d9ef">long</span> p){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(b <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>((b <span style="color:#f92672">&amp;</span> 1) <span style="color:#f92672">==</span> 1) res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>            b <span style="color:#f92672">=</span> b <span style="color:#f92672">&gt;&gt;</span> 1;
</span></span><span style="display:flex;"><span>            a <span style="color:#f92672">=</span> a <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>组合3</strong></p>
<p>卢卡斯定理：当a和b很大10^18时的优化。
$$
C_a^b 同余C_{amodp}^{bmodp}*C_{a/p}^{b/p}(modp)
$$</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> p <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(n <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> a <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextLong</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> b <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextLong</span>();
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextLong</span>();
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(lucas(a,b));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">lucas</span>(<span style="color:#66d9ef">long</span> a,<span style="color:#66d9ef">long</span> b){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(a <span style="color:#f92672">&lt;</span> p <span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">&lt;</span> p) <span style="color:#66d9ef">return</span> C(a,b);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> C(a <span style="color:#f92672">%</span> p,b <span style="color:#f92672">%</span> p) <span style="color:#f92672">*</span> lucas(a <span style="color:#f92672">/</span> p,b <span style="color:#f92672">/</span> p) <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//从定义入手a×(a-1)×(a-2)×...(a - b + 1)/b × (b - 1) ×...1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">C</span>(<span style="color:#66d9ef">long</span> a,<span style="color:#66d9ef">long</span> b){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> a <span style="color:#f92672">-</span> b <span style="color:#f92672">+</span> 1,j <span style="color:#f92672">=</span> 1;j <span style="color:#f92672">&lt;=</span> b;i <span style="color:#f92672">++</span>,j <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> i <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> qmi(j,p <span style="color:#f92672">-</span> 2) <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">qmi</span>(<span style="color:#66d9ef">long</span> a,<span style="color:#66d9ef">long</span> b){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(b <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>((b <span style="color:#f92672">&amp;</span> 1) <span style="color:#f92672">==</span> 1) res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>            b <span style="color:#f92672">&gt;&gt;=</span> 1;
</span></span><span style="display:flex;"><span>            a <span style="color:#f92672">=</span> a <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="9容斥原理">9.容斥原理
</h3><p>韦恩图两个圆、三个圆的面积推广至四个圆甚至更多。等价于求N个集合不同元素的方法。</p>
<p>C<!-- raw HTML omitted -->n<!-- raw HTML omitted --><!-- raw HTML omitted -->0<!-- raw HTML omitted -->+C<!-- raw HTML omitted -->n<!-- raw HTML omitted --><!-- raw HTML omitted -->1<!-- raw HTML omitted --> +C<!-- raw HTML omitted -->n<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted -->+C<!-- raw HTML omitted -->n<!-- raw HTML omitted --><!-- raw HTML omitted -->3<!-- raw HTML omitted -->+&hellip;..+C<!-- raw HTML omitted -->n<!-- raw HTML omitted --><!-- raw HTML omitted -->n<!-- raw HTML omitted -->=从n个数里选任意个数的方法，即每种数都有选和不选=2<!-- raw HTML omitted -->n<!-- raw HTML omitted --></p>
<p>C<!-- raw HTML omitted -->k<!-- raw HTML omitted --><!-- raw HTML omitted -->1<!-- raw HTML omitted -->-C<!-- raw HTML omitted -->k<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted --> +C<!-- raw HTML omitted -->k<!-- raw HTML omitted --><!-- raw HTML omitted -->3<!-- raw HTML omitted -->-C<!-- raw HTML omitted -->k<!-- raw HTML omitted --><!-- raw HTML omitted -->4<!-- raw HTML omitted -->+&hellip;..+(-1)<!-- raw HTML omitted -->k-1<!-- raw HTML omitted -->C<!-- raw HTML omitted -->k<!-- raw HTML omitted --><!-- raw HTML omitted -->k<!-- raw HTML omitted -->=1</p>
<p>对于能同时被k个质数整除的个数=[N/p<!-- raw HTML omitted -->1<!-- raw HTML omitted -->p<!-- raw HTML omitted -->2<!-- raw HTML omitted -->p<!-- raw HTML omitted -->3<!-- raw HTML omitted -->&hellip;p<!-- raw HTML omitted -->k<!-- raw HTML omitted -->]</p>
<p>暴力做法：O(N)枚举每个数是否符合条件——&gt;O(2<!-- raw HTML omitted -->m<!-- raw HTML omitted -->)=O(2<!-- raw HTML omitted -->65536<!-- raw HTML omitted -->).共有n个数 是否被m个数整除 需枚举2<!-- raw HTML omitted -->m<!-- raw HTML omitted -->次（每个数都可以用和被用）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextLong</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span><span style="color:#f92672">[]</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">[</span>20<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> m;i <span style="color:#f92672">++</span> ) p<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextLong</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;</span> 1 <span style="color:#f92672">&lt;&lt;</span> m;i <span style="color:#f92672">++</span> ){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> m;j <span style="color:#f92672">++</span> ){ 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>((b <span style="color:#f92672">&amp;</span> 1) <span style="color:#f92672">==</span> 1)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cnt <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span>((<span style="color:#66d9ef">long</span>)t <span style="color:#f92672">*</span> p<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> n){
</span></span><span style="display:flex;"><span>                        cnt <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    t <span style="color:#f92672">*=</span> p<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                b <span style="color:#f92672">&gt;&gt;=</span> 1;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//周期性+-</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(cnt <span style="color:#f92672">&gt;</span> 0){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>((cnt <span style="color:#f92672">%</span> 2) <span style="color:#f92672">==</span> 1) res <span style="color:#f92672">+=</span> n <span style="color:#f92672">/</span> t;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> res <span style="color:#f92672">-=</span> n <span style="color:#f92672">/</span> t;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="10简单博弈论">10.简单博弈论
</h3><p>思路</p>
<ul>
<li>核心是找到规律</li>
</ul>
<p>1.公平组合游戏ICG</p>
<p>若一个游戏满足：1.由两名玩家交替行动；2.在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；3.不能行动的玩家判负则称该游戏为一个公平组合游戏。NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足icg规则。</p>
<p>这种无论先手、后手状态都采取最佳策略（仍然是找规律解决此类问题）。必胜必败状态指先手必胜（即后手必败，一定能变为必败状态）或先手必败（先手无论怎么操作都必败）。</p>
<p>2.Mex运算</p>
<p>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：mex(S)=min(x)，x属于自然数，且x不属于S</p>
<p>3.SG函数</p>
<p>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1 ,y2 ,y3 ,&hellip;yk,定义SG(x)为x的后继节点y1 ,y2 ,y3 ,&hellip;yk的SG函数值构成的集合再执行mex(S)运算的结果，即：SG(x)=mex({SG(y1), SG(y2),  &hellip; ,SG(yk)})</p>
<p>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G)=SG(s)</p>
<p>SG(x)=0必胜</p>
<p>SG(x)≠0必败</p>
<h4 id="nim游戏">Nim游戏
</h4><p>题目描述：给定 n 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。</p>
<p>问如果两人都采用最优策略，先手是否必胜。</p>
<p>输入格式</p>
<p>第一行包含整数 n。</p>
<p>第二行包含 n 个数字，其中第 ii 个数字表示第 ii 堆石子的数量。</p>
<p>输出格式</p>
<p>如果先手方必胜，则输出 <code>Yes</code>。</p>
<p>否则，输出 <code>No</code>。</p>
<p>数据范围</p>
<p>1≤n≤10<!-- raw HTML omitted -->5<!-- raw HTML omitted -->,
1≤每堆石子数≤10<!-- raw HTML omitted -->9<!-- raw HTML omitted --></p>
<p>输入样例：</p>
<pre tabindex="0"><code>2
2 3
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>Yes
</code></pre><p>解题思路：设有n堆石子 每堆石子个数分别为a<!-- raw HTML omitted -->1<!-- raw HTML omitted --> ,a<!-- raw HTML omitted -->2<!-- raw HTML omitted --> ,a<!-- raw HTML omitted -->3<!-- raw HTML omitted --> &hellip;.a<!-- raw HTML omitted -->n<!-- raw HTML omitted --></p>
<p>若 a<!-- raw HTML omitted -->1<!-- raw HTML omitted -->⊕a<!-- raw HTML omitted -->2<!-- raw HTML omitted --> ⊕a<!-- raw HTML omitted -->3<!-- raw HTML omitted --> ⊕ &hellip;⊕a<!-- raw HTML omitted -->n<!-- raw HTML omitted --> =0 则先手必败；若a<!-- raw HTML omitted -->1<!-- raw HTML omitted -->⊕a<!-- raw HTML omitted -->2<!-- raw HTML omitted --> ⊕a<!-- raw HTML omitted -->3<!-- raw HTML omitted --> ⊕ &hellip;⊕a<!-- raw HTML omitted -->n<!-- raw HTML omitted --> ≠0则先手必胜</p>
<p>下证此结论正确</p>
<h4 id="集合-nim游戏">集合-Nim游戏
</h4><h4 id="台阶-nim游戏">台阶-Nim游戏
</h4><h2 id="5动态规划">5.动态规划
</h2><p><strong>找到如何状态转移很难！！！！！！！！！</strong></p>
<p><strong>本质上DP问题可以为最短路问题，这是可当作最短路来求解 并注意定义不连通的路径赋予无穷小的负权。</strong></p>
<p>时间复杂度 = 状态数量 * 转移数量</p>
<p>ps：常用dp模型。dp的优化往往是对代码和计算函数的等价变形。</p>
<p>特点或解题关键：</p>
<p>1.考虑解题维度</p>
<p>2.用子问题定义状态 写出状态转移方程</p>
<p>DP优于DFS在于能减少很多不必要的状态 动态规划 用一个状态表示所有最值 DFS是遍历所有状态</p>
<h3 id="1背包问题">1.背包问题
</h3><p>注意</p>
<ul>
<li>可简单理解为 如果需要用到第i-1行 即前一行的数据时 优化时 需逆序。如果是本行的数据 则不用</li>
</ul>
<p>许多问题可抽象成背包模型</p>
<p>（B站详细背包问题大全 up主：大雪菜 <a class="link" href="https://www.bilibili.com/video/BV1qt411Z7nE?p=2&amp;spm_id_from=pageDriver"  target="_blank" rel="noopener"
    >背包九讲专题_哔哩哔哩_bilibili</a>具体文章 见 dd大牛的背包九讲 <a class="link" href="https://www.cnblogs.com/jbelial/articles/2116074.html"  target="_blank" rel="noopener"
    >https://www.cnblogs.com/jbelial/articles/2116074.html</a>）</p>
<h4 id="101背包问题">1.01背包问题
</h4><p>1.问题描述：有N个物体，一个容量为V的背包。每件物体价值为w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，体积为v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，每件物品<strong>只能用一次</strong>。求在装不超过背包容量的前提下，使物品的价值和最大。</p>
<p>2.dp问题分析(可通用)： <strong>不重不漏的集合划分（状态表示）</strong></p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR;
	A[Dp]--&gt;B[状态表示]
	A--&gt;C[状态计算]
	B--&gt;D[集合]
	B--&gt;E[属性]
	D--&gt;F[所有选项]
	D--&gt;G[条件]
	G--&gt;H[只从前i个物品中选择]
	G--&gt;I[总体积不超过容量j]
	E--&gt;J[min,max,number]
	C--&gt;K[集合划分]
</code></pre><p>思路：将该dp问题作为二维集合分析f(i,j)(f(i,j)表示最大价值)。i表示可选物品(编号已默认确定)，j表示背包体积。f(N，V)即为所求。</p>
<p>f(i,i)=max{不含第i个物品的最大价值化选择，含第i个物品的最大价值化选择}=max{f(i-1,j),f(i-1,j-v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->)+w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->}。逐次递归。</p>
<p>3.代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">1010</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//n为物品数量 m为背包容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//v[i]为物品体积,w[i]为物品价值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> v[N],w[N];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//二维考虑二维数组(连续性 如i,j为连续性变化) 初始化默认为元素均为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> f[N][N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//i从1开始(0个物品没有意义) j从容量为0开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) cin<span style="color:#f92672">&gt;&gt;</span>v[i]<span style="color:#f92672">&gt;&gt;</span>w[i];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//调换两个for循环的顺序是一致的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;=</span>m;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//f[i][j]=f[i-1][j]是必有的 只有当j&gt;=v[i]才有f[i-1][j-v[i]]+w[i])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			f[i][j]<span style="color:#f92672">=</span>f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(j<span style="color:#f92672">&gt;=</span>v[i]) f[i][j]<span style="color:#f92672">=</span>max(f[i][j],f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span>v[i]]<span style="color:#f92672">+</span>w[i]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	cout<span style="color:#f92672">&lt;&lt;</span>f[n][m]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>简化代码</p>
<p><em>1）初简化 可删掉条件直接将j从v[i]处开始计算</em>(<strong>错误的做法</strong>) 示例：n=4 m=4;4 1;2 9;4 7;2 8; 应为17 实为9；</p>
<p><strong>原因 ：直接从j=v[i]处开始 中间值没有赋值导致错误</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>v[i];j<span style="color:#f92672">&lt;=</span>m;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>            f[i][j]<span style="color:#f92672">=</span>max(f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j],f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span>v[i]]<span style="color:#f92672">+</span>w[i]);
</span></span><span style="display:flex;"><span>		}
</span></span></code></pre></div><p>2）二维转换为一维数组</p>
<p>二维转化为一维：
删掉了第一维：在前i个物品中取。
f[j]表示：拿了总体积不超过j的物品，最大总价值。</p>
<p>为何能转化为一维？<strong>滚动数组</strong>
二维时的更新方式：f[i][j]=max(f（i - 1，j） ,f（i - 1，j - v[i]] + w[i]）);
1.<strong>我们发现，对于每次循环的下一组i，只会用到i-1来更新当前值，不会用到i-2及之前值。于是可以在这次更新的时候，将原来的更新掉，反正以后也用不到。</strong>
<strong>所以对于i的更新，只需用一个数组，直接覆盖就行了。随着时间 自动覆盖</strong>
2.我们发现，对于每次j的更新，只需用到之前i-1时的j或者j-v[i]，不会用到后面的值。
所以为了防止串着改，我们采取从后往前更新的方式，用原来i-1的数组来更新i。
（如果从前往后更新的话，前面的更新过之后，会接着更新后面的值，<strong>这样就不能保证是用原来i-1的数组</strong>来更新i的了）相当于是保留了需要的那部分的backup</p>
<p>如何转化为一维呢？
只用一个数组，每次都覆盖前面的数组。</p>
<p>1.如果当前位置的东西不拿的话，和前一位置的信息（原来i-1数组的这个位置上的值）是相同的，所以不用改变。
2.如果当前位置的东西拿了的话，需要和前一位置的信息（原来i-1数组的这个位置上值）取max。
所以，更新方式就为：f[j]=max(f[j],f[j-v[i]]+w[i]);</p>
<p>整个更新方式就相当于：</p>
<p>每次i++，就从后往前覆盖一遍f数组，看每个位置上的值是否更新。</p>
<p>简化思路：在计算中，i只用于i-1所以考虑省略，用滚动数组即对于此二维数组来说，每一行最多考虑上一行的值。</p>
<p>ps:若直接转化为一维 下面代码不等价上式代码</p>
<p>由于f[j]是从小到大的增加 f[j-v[i]]实际上为 f[i] [j-v[i]]不等价于f[i-1] [j-v[i]]</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>v[i];j<span style="color:#f92672">&lt;=</span>m;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>            f[j]<span style="color:#f92672">=</span>max(f[j],f[j<span style="color:#f92672">-</span>v[i]]<span style="color:#f92672">+</span>w[i]);
</span></span><span style="display:flex;"><span>		}
</span></span></code></pre></div><p>解决办法：考虑调换j的顺序使之递减。此时当开始计算某i行的f[j]时 此时的第j-v[i]列还未计算 而此时的f[j-v[i]]保存的是第i-1行的值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">1010</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v[N],w[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) cin<span style="color:#f92672">&gt;&gt;</span>v[i]<span style="color:#f92672">&gt;&gt;</span>w[i];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//不断更新f[j]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>m;j<span style="color:#f92672">&gt;=</span>v[i];j<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>            f[j]<span style="color:#f92672">=</span>max(f[j],f[j<span style="color:#f92672">-</span>v[i]]<span style="color:#f92672">+</span>w[i]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	cout<span style="color:#f92672">&lt;&lt;</span>f[m]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2完全背包问题">2.完全背包问题
</h4><p>1.问题描述：有N个物体，一个容量为V的背包。每件物体价值为w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，体积为v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，<strong>每件物品有无限个</strong>。求在装不超过背包容量的前提下，使物品的价值和最大。</p>
<p>2.问题分析</p>
<p>将该dp问题作为二维集合分析f(i,j)(f(i,j)表示最大价值)。i表示可选物品(编号已默认确定)，j表示背包体积。f(N，V)即为所求。</p>
<p>f(i,j)=max{不含第i个物品的最大价值化选择，选1个第i个物品的最大价值化选择，选1个第i个物品的最大价值化选择}=max{f(i-1,j),f(i-1,j-v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->)+w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->}。逐次递归。</p>
<p>3.代码</p>
<p>1）最朴素代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">1010</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v[N],w[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f[N][N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) cin<span style="color:#f92672">&gt;&gt;</span>v[i]<span style="color:#f92672">&gt;&gt;</span>w[i];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;=</span>m;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		 	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;k<span style="color:#f92672">*</span>v[i]<span style="color:#f92672">&lt;=</span>j;k<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//不断更新f[i][j] 先比较f[i][j]和f[i-1][j] 保留最大值 便不断比较取1个，2个，3个.....的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		 		f[i][j]<span style="color:#f92672">=</span>max(f[i][j],f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span>k<span style="color:#f92672">*</span>v[i]]<span style="color:#f92672">+</span>k<span style="color:#f92672">*</span>w[i]);
</span></span><span style="display:flex;"><span>	cout<span style="color:#f92672">&lt;&lt;</span>f[n][m]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>缺点：三重循环 最坏时间复杂度T(n* m*j) （当v[i]=1时）时间太长</p>
<p>2）简化代码</p>
<p>思路：删去循环 删除与k的联系 找和前面数组元素之间的联系 用已知的元素来计算</p>
<p>观察不难发现</p>
<p>f[i] [j]=Max{f[i-1] [j], f[i-1] [j-v[i]]+<strong>w[i]</strong>, f[i-1] [j-2* v[i]]+<em><em>2</em> w[i],</em>* f[i-1] [j-3* v[i]]+<em><em>3</em> w[i]</em>*,&hellip;&hellip;&hellip;.}</p>
<p>f[i] [j-v[i]]=Max{ <strong>f[i-1] [j-v[i]]</strong>, <em><em>f[i-1] [j-2</em> v[i]]+w[i]</em><em>, <em><em>f[i-1] [j-3</em> v[i]]+2</em> w[i]</em>*, &hellip;&hellip;&hellip;&hellip;}</p>
<p>易得f[i] [j]=Max{f[i-1] [j], <strong>f[i] [j-v[i]]+w[i]</strong>}</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;=</span>m;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			f[i][j]<span style="color:#f92672">=</span>f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j];
</span></span><span style="display:flex;"><span>		 	<span style="color:#66d9ef">if</span>(j<span style="color:#f92672">&gt;=</span>v[i]) f[i][j]<span style="color:#f92672">=</span>max(f[i][j],f[i][j<span style="color:#f92672">-</span>v[i]]<span style="color:#f92672">+</span>w[i]);
</span></span><span style="display:flex;"><span>		 	}
</span></span></code></pre></div><p>进一步简化 二维转一维(ps :这里就没有01背包问题所考虑的需要调换顺序 需要的就是第i行的元素)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">1010</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v[N],w[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) cin<span style="color:#f92672">&gt;&gt;</span>v[i]<span style="color:#f92672">&gt;&gt;</span>w[i];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>v[i];j<span style="color:#f92672">&lt;=</span>m;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			 f[j]<span style="color:#f92672">=</span>max(f[j],f[j<span style="color:#f92672">-</span>v[i]]<span style="color:#f92672">+</span>w[i]);
</span></span><span style="display:flex;"><span>	cout<span style="color:#f92672">&lt;&lt;</span>f[m]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3多重背包问题">3.多重背包问题
</h4><p>1.问题描述：有 N 种物品和一个容量是 V的背包。第 i种物品最多有 s<!-- raw HTML omitted -->i<!-- raw HTML omitted --> 件，每件体积是 v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，价值是 w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。</p>
<p>2.问题分析：同上完全背包问题 只是多加个限制k&lt;=s[i]</p>
<p>3.代码</p>
<p>暴力解法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">110</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v[N],w[N],s[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f[N][N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) cin<span style="color:#f92672">&gt;&gt;</span>v[i]<span style="color:#f92672">&gt;&gt;</span>w[i]<span style="color:#f92672">&gt;&gt;</span>s[i];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;=</span>m;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;k<span style="color:#f92672">&lt;=</span>s[i]<span style="color:#f92672">&amp;&amp;</span>k<span style="color:#f92672">*</span>v[i]<span style="color:#f92672">&lt;=</span>j;k<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>				f[i][j]<span style="color:#f92672">=</span>max(f[i][j],f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span>k<span style="color:#f92672">*</span>v[i]]<span style="color:#f92672">+</span>k<span style="color:#f92672">*</span>w[i]);
</span></span><span style="display:flex;"><span>	cout<span style="color:#f92672">&lt;&lt;</span>f[n][m]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>2）二进制优化</p>
<p>数据范围</p>
<p>0&lt;N≤1000
0&lt;V≤2000
0&lt;v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,s<!-- raw HTML omitted -->i<!-- raw HTML omitted -->≤2000</p>
<p>当数据范围扩大 明显会超时。若考虑使用完全背包问题的优化思路，则</p>
<p>f[i] [j]=max{f[i-1] [j] ,f[i-1] [j-v[i]]+w[i] ,f[i-1] [j-2* v[i]]+2* w[i] ,f[i-1] [j-3* v[i]]+3* w[i] &hellip;&hellip;.f[i-1] [j-s[i]* v[i]]+s[i]* w[i]}</p>
<p>f[i] [j-v[i]]=max{f[i-1] [j-v[i]] ,f[i-1] [j-2* v[i]]+ w[i] ,f[i-1] [j-3* v[i]]+2* w[i] &hellip;&hellip;.f[i-1] [j-s[i]* v[i]]+(s[i]-1)* w[i] ,f[i-1] [j-(s[i]+1)* v[i]]+s[i]* w[i] } 无法求解 比如当v[i] * s[i] &lt; j 时就不能用完全背包来优化</p>
<p>优化思想：设第i种物品有s[i]个如1023（逐个枚举k 时间复杂度过大）可以将其分组每组个数为1、2、4、8、16、&hellip;512   不难发现可以在保证每组只用一次的情况下表示出0~1023的所有数字（如：1和2可表示出0-3 则1、2、4可表示出0-7） 更一般的对任意s 可将其拆分为s=1+2+4+&hellip;..+2<!-- raw HTML omitted -->k-1<!-- raw HTML omitted -->+C(C=s-2<!-- raw HTML omitted -->k<!-- raw HTML omitted -->+1)   最后将他们每组都当作一种物品(体积为2<!-- raw HTML omitted -->i<!-- raw HTML omitted -->* a 价值为2<!-- raw HTML omitted -->i<!-- raw HTML omitted -->* b)，最后采用01背包问题解决（比如将这两种物品进行组合 其实为凑出0-s中的某个个数的同种物品）。</p>
<p>代码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">25000</span>,M<span style="color:#f92672">=</span><span style="color:#ae81ff">2010</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//扩展思路2000*log(2000)约为25000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v[N],w[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//cnt作为标志 扩展物品数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> cnt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//a为体积 b为价值 s为个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> a,b,s;
</span></span><span style="display:flex;"><span>		cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b<span style="color:#f92672">&gt;&gt;</span>s;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span>(k<span style="color:#f92672">&lt;=</span>s){
</span></span><span style="display:flex;"><span>			cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			v[cnt]<span style="color:#f92672">=</span>k<span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>			w[cnt]<span style="color:#f92672">=</span>k<span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>			s<span style="color:#f92672">-=</span>k;
</span></span><span style="display:flex;"><span>			k<span style="color:#f92672">*=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(s<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>			cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			v[cnt]<span style="color:#f92672">=</span>s<span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>			w[cnt]<span style="color:#f92672">=</span>s<span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//最后采用01背包问题解决
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>cnt;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>m;j<span style="color:#f92672">&gt;=</span>v[i];j<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>			f[j]<span style="color:#f92672">=</span>max(f[j],f[j<span style="color:#f92672">-</span>v[i]]<span style="color:#f92672">+</span>w[i]);
</span></span><span style="display:flex;"><span>	cout<span style="color:#f92672">&lt;&lt;</span>f[m]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>时间复杂度从T(N* V* S)=&gt;T(N* V* logS)</p>
<p>3）单调队列优化 滑动窗口</p>
<p>思路：将f[i, j]、f[i, j - v]、&hellip;f[i, r]（r为j模v的余数）平铺在数轴上，不难发现每次求前s个最大的值，实质上为滑动窗口模型：线性时间求</p>
<p>完全背包实质上求前缀的最大值，多重背包实质上求滑动窗口的最大值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">20010</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f[N], g[N], q[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v, w, s;
</span></span><span style="display:flex;"><span>        cin <span style="color:#f92672">&gt;&gt;</span> v <span style="color:#f92672">&gt;&gt;</span> w <span style="color:#f92672">&gt;&gt;</span> s;
</span></span><span style="display:flex;"><span>        memcpy(g, f, <span style="color:#66d9ef">sizeof</span> f);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> v; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> hh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, tt <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> j; k <span style="color:#f92672">&lt;=</span> m; k <span style="color:#f92672">+=</span> v)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (hh <span style="color:#f92672">&lt;=</span> tt <span style="color:#f92672">&amp;&amp;</span> q[hh] <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">-</span> s <span style="color:#f92672">*</span> v) hh <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (hh <span style="color:#f92672">&lt;=</span> tt <span style="color:#f92672">&amp;&amp;</span> g[q[tt]] <span style="color:#f92672">-</span> (q[tt] <span style="color:#f92672">-</span> j) <span style="color:#f92672">/</span> v <span style="color:#f92672">*</span> w <span style="color:#f92672">&lt;=</span> g[k] <span style="color:#f92672">-</span> (k <span style="color:#f92672">-</span> j) <span style="color:#f92672">/</span> v <span style="color:#f92672">*</span> w) tt <span style="color:#f92672">--</span> ;
</span></span><span style="display:flex;"><span>                q[ <span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> k;
</span></span><span style="display:flex;"><span>                f[k] <span style="color:#f92672">=</span> g[q[hh]] <span style="color:#f92672">+</span> (k <span style="color:#f92672">-</span> q[hh]) <span style="color:#f92672">/</span> v <span style="color:#f92672">*</span> w;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> f[m] <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="4分组背包问题">4.分组背包问题
</h4><p>1.问题描述：有 N 组物品和一个容量是 V 的背包。每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 v<!-- raw HTML omitted -->ij<!-- raw HTML omitted -->，价值是 w<!-- raw HTML omitted -->ij<!-- raw HTML omitted -->，其中 i 是组号，j 是组内编号。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。</p>
<p>2.问题分析：</p>
<p>定义f[i , j]为从前i组中选择 背包容量为j。</p>
<p>f(i , j)=Max{f(i-1 , j) , 第i组选第一个的最大价值化选择，第i组选第2个的最大价值化选择，&hellip;.,第i组选第j个的最大价值化选择}</p>
<p>其中第i组选第k个的最大价值化选择的状态转移方程=f[i-1] [j-v[i] [k]]+w[i] [k]</p>
<p>ps:使用一维数组时 此时转移方程依赖上一行的元素 所以j应该从大到小递减 若是本行则从小到大</p>
<p>3.代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">110</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//s[i]表示第i组物品个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> v[N][N],w[N][N],s[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		cin<span style="color:#f92672">&gt;&gt;</span>s[i];
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>s[i];j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			cin<span style="color:#f92672">&gt;&gt;</span>v[i][j]<span style="color:#f92672">&gt;&gt;</span>w[i][j];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//这里没加j的限制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>m;j<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">--</span>)<span style="color:#75715e">//j 和 k 调换顺序导致结果不一致 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//调换后 含义改变 从第k组选出体积不大于j的最大价值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;k<span style="color:#f92672">&lt;</span>s[i];k<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//把j的限制放在此处
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(v[i][k]<span style="color:#f92672">&lt;=</span>j)	f[j]<span style="color:#f92672">=</span>max(f[j],f[j<span style="color:#f92672">-</span>v[i][k]]<span style="color:#f92672">+</span>w[i][k]);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>	cout<span style="color:#f92672">&lt;&lt;</span>f[m]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><h4 id="5混合背包问题">5.混合背包问题
</h4><p>1.问题描述：有 N 种物品和一个容量是 V 的背包。</p>
<p>物品一共有三类：</p>
<ul>
<li>第一类物品只能用1次（01背包）；</li>
<li>第二类物品可以用无限次（完全背包）；</li>
<li>第三类物品最多只能用 s<!-- raw HTML omitted -->i<!-- raw HTML omitted --> 次（多重背包）；</li>
</ul>
<p>每种体积是 v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，价值是 w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。</p>
<p>输入格式</p>
<p>第一行两个整数，N，V 用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 N 行，每行三个整数 v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,s<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，用空格隔开，分别表示第 i种物品的体积、价值和数量。</p>
<ul>
<li>s<!-- raw HTML omitted -->i<!-- raw HTML omitted -->=−1 表示第 i 种物品只能用1次；</li>
<li>s<!-- raw HTML omitted -->i<!-- raw HTML omitted -->=0表示第 i 种物品可以用无限次；</li>
<li>s<!-- raw HTML omitted -->i<!-- raw HTML omitted -->&gt;0 表示第 i种物品可以使用 s<!-- raw HTML omitted -->i<!-- raw HTML omitted -->次；</li>
</ul>
<p>输出格式</p>
<p>输出一个整数，表示最大价值。</p>
<p>数据范围</p>
<p>0&lt;N,V≤1000
0&lt;v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->≤1000
−1≤s<!-- raw HTML omitted -->i<!-- raw HTML omitted -->≤1000</p>
<p>输入样例</p>
<pre tabindex="0"><code>4 5
1 2 -1
2 4 1
3 4 0
4 5 2
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>8
</code></pre><p>2.问题分析</p>
<p>[思路一] 将三者01背包问题 完全背包问题 混合背包问题 全部转化为01背包问题。类似于二进制优化，将它们全部打散作为01背包。对于完全背包问题，即无限个个数时，也会由于不能超过背包体积而可看作有限个个数，所以这里也可以考虑二进制优化。</p>
<p>3.代码</p>
<p>[思路一]</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">1000000</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v[N],w[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> cnt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//拆分成01背包问题  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> a,b,c;
</span></span><span style="display:flex;"><span>		cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b<span style="color:#f92672">&gt;&gt;</span>c;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//01背包 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(c<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>			cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			v[cnt]<span style="color:#f92672">=</span>a;
</span></span><span style="display:flex;"><span>			w[cnt]<span style="color:#f92672">=</span>b;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//完全背包 前提条件为总和不大于m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(c<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span>(a<span style="color:#f92672">*</span>k<span style="color:#f92672">&lt;=</span>m){
</span></span><span style="display:flex;"><span>			cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			v[cnt]<span style="color:#f92672">=</span>a;
</span></span><span style="display:flex;"><span>			w[cnt]<span style="color:#f92672">=</span>b;
</span></span><span style="display:flex;"><span>			k<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//多重背包 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(c<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span>(k<span style="color:#f92672">&lt;=</span>c){
</span></span><span style="display:flex;"><span>			cnt<span style="color:#f92672">++</span>; 
</span></span><span style="display:flex;"><span>			v[cnt]<span style="color:#f92672">=</span>k<span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>			w[cnt]<span style="color:#f92672">=</span>k<span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>			c<span style="color:#f92672">-=</span>k;
</span></span><span style="display:flex;"><span>			k<span style="color:#f92672">*=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(c<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>			cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			v[cnt]<span style="color:#f92672">=</span>c<span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>			w[cnt]<span style="color:#f92672">=</span>c<span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//转化成一维背包 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>cnt;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>m;j<span style="color:#f92672">&gt;=</span>v[i];j<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>			f[j]<span style="color:#f92672">=</span>max(f[j],f[j<span style="color:#f92672">-</span>v[i]]<span style="color:#f92672">+</span>w[i]);
</span></span><span style="display:flex;"><span>	cout<span style="color:#f92672">&lt;&lt;</span>f[m]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span></code></pre></div><p>最坏时间复杂度 T（2* n* m）</p>
<p>思路一优化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//拆分成01背包问题  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> a,b,c;
</span></span><span style="display:flex;"><span>		cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b<span style="color:#f92672">&gt;&gt;</span>c;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//01背包 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(c<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>			cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			v[cnt]<span style="color:#f92672">=</span>a;
</span></span><span style="display:flex;"><span>			w[cnt]<span style="color:#f92672">=</span>b;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//多重背包 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(c<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(c<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span>(a<span style="color:#f92672">*</span>t<span style="color:#f92672">&lt;=</span>m){
</span></span><span style="display:flex;"><span>				t<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			c<span style="color:#f92672">=</span>t<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;	
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span>(k<span style="color:#f92672">&lt;=</span>c){
</span></span><span style="display:flex;"><span>			cnt<span style="color:#f92672">++</span>; 
</span></span><span style="display:flex;"><span>			v[cnt]<span style="color:#f92672">=</span>k<span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>			w[cnt]<span style="color:#f92672">=</span>k<span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>			c<span style="color:#f92672">-=</span>k;
</span></span><span style="display:flex;"><span>			k<span style="color:#f92672">*=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(c<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>			cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			v[cnt]<span style="color:#f92672">=</span>c<span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>			w[cnt]<span style="color:#f92672">=</span>c<span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>最坏时间复杂度T（2* n* m）</p>
<h4 id="6二维费用的背包">6.二维费用的背包
</h4><p>1.问题描述</p>
<p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。</p>
<p>每件物品只能用一次。体积是 v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，重量是 m<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，价值是 w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。
输出最大价值。</p>
<p>输入格式</p>
<p>第一行三个整数，N,V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p>
<p>接下来有 N 行，每行三个整数 v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,m<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，用空格隔开，分别表示第 i件物品的体积、重量和价值。</p>
<p>输出格式</p>
<p>输出一个整数，表示最大价值。</p>
<p>数据范围</p>
<p>0&lt;N≤1000
0&lt;V,M≤100
0&lt;v<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,m<!-- raw HTML omitted -->i<!-- raw HTML omitted -->≤100
0&lt;w<!-- raw HTML omitted -->i<!-- raw HTML omitted -->≤1000</p>
<p>2.问题分析</p>
<p>1.所谓二维 即物品受两种代价的限制。单纯增加一维的限制</p>
<p>3.代码</p>
<p>1）最朴素的代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">1010</span>,M<span style="color:#f92672">=</span><span style="color:#ae81ff">110</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,vk,mk;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v[N],w[N],m[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f[N][M][M];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>vk<span style="color:#f92672">&gt;&gt;</span>mk;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) cin<span style="color:#f92672">&gt;&gt;</span>v[i]<span style="color:#f92672">&gt;&gt;</span>m[i]<span style="color:#f92672">&gt;&gt;</span>w[i];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;=</span>vk;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;k<span style="color:#f92672">&lt;=</span>mk;k<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>				f[i][j][k]<span style="color:#f92672">=</span>f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j][k];
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span>(j<span style="color:#f92672">&gt;=</span>v[i]<span style="color:#f92672">&amp;&amp;</span>k<span style="color:#f92672">&gt;=</span>m[i]) f[i][j][k]<span style="color:#f92672">=</span>max(f[i][j][k],f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span>v[i]][k<span style="color:#f92672">-</span>m[i]]<span style="color:#f92672">+</span>w[i]);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>	cout<span style="color:#f92672">&lt;&lt;</span>f[n][vk][mk]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>优化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1010,V <span style="color:#f92672">=</span> 110,M <span style="color:#f92672">=</span> 110,n,v,m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> wi <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> vi <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> mi <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>V<span style="color:#f92672">][</span>M<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        v <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            vi<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            mi<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            wi<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> v;j <span style="color:#f92672">&gt;=</span> vi<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;j <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> m;k <span style="color:#f92672">&gt;=</span> mi<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;k <span style="color:#f92672">--</span> )<span style="color:#75715e">//调换这两层循环的顺序 结果不变</span>
</span></span><span style="display:flex;"><span>                    f<span style="color:#f92672">[</span>j<span style="color:#f92672">][</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(f<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> vi<span style="color:#f92672">[</span>i<span style="color:#f92672">]][</span>k <span style="color:#f92672">-</span> mi<span style="color:#f92672">[</span>i<span style="color:#f92672">]]</span> <span style="color:#f92672">+</span> wi<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>j<span style="color:#f92672">][</span>k<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(f<span style="color:#f92672">[</span>v<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="7背包问题求方案数">7.背包问题求方案数
</h4><p>1.问题描述 如01背包问题方案数 值恰好为m的方案数</p>
<p>2.问题分析</p>
<p>f[0,0] = 1;</p>
<p>f[i,j] = f[i - 1,j] + f[i - 1,j - v[i]] 方案数等于不要第i个数的+要第i个数的</p>
<p>3.代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1010,n,m,mod <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)1e9 <span style="color:#f92672">+</span> 7;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> g <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//状态转移条件定义为恰好等于体积m时的 最大价值量 当j==0时 赋值为0 其余为负无穷 认为此路不通</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> N;i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 1;j <span style="color:#f92672">&lt;</span> N;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>0x3f3f3f3f;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        g<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1;<span style="color:#75715e">//i等于其他的情况 不用赋值1 根据状态定义 不然重复</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;=</span> m;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> f<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(j <span style="color:#f92672">&gt;=</span> v) f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> w);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> f<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>) g<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> (g<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> g<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>) <span style="color:#f92672">%</span> mod;<span style="color:#75715e">//说明路径来源为g[i - 1][j]</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(j <span style="color:#f92672">&gt;=</span> v <span style="color:#f92672">&amp;&amp;</span> f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> f<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> w) g<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> (g<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> g<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> v<span style="color:#f92672">]</span>) <span style="color:#f92672">%</span> mod;<span style="color:#75715e">//说明路径来源为g[i - 1][j - v] 可能二者相同就正好两条路径都加上</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//由于转变了 状态转移条件定义为恰好等于体积m时的 所以需遍历得到 最大价值</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> N;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> N;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                res <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(res,f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//无需遍历i 0~n的情况 不然会重复 根据状态定义 用前i个物品 且 体积恰好等于j的方案数 即只需遍历不同体积即可</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;=</span> m;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(f<span style="color:#f92672">[</span>n<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> res) cnt <span style="color:#f92672">+=</span> g<span style="color:#f92672">[</span>n<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(cnt);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一维优化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1010,n,m,mod <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)1e9 <span style="color:#f92672">+</span> 7;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> g <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//状态转移条件定义为恰好等于体积m时的 最大价值量 当j==0时 赋值为0 其余为负无穷 认为此路不通</span>
</span></span><span style="display:flex;"><span>        Arrays.<span style="color:#a6e22e">fill</span>(f,<span style="color:#f92672">-</span>0x3f3f3f3f);
</span></span><span style="display:flex;"><span>        f<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        g<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m;j <span style="color:#f92672">&gt;=</span> v;j <span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> maxv <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(f<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> w);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(maxv <span style="color:#f92672">==</span> f<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>) cnt <span style="color:#f92672">+=</span> g<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>;<span style="color:#75715e">//说明路径来源为g[i - 1][j]</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(maxv <span style="color:#f92672">==</span> f<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> w) cnt <span style="color:#f92672">+=</span> g<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> v<span style="color:#f92672">]</span>;<span style="color:#75715e">//说明路径来源为g[i - 1][j - v] 可能二者相同就正好两条路径都加上</span>
</span></span><span style="display:flex;"><span>                f<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> maxv;
</span></span><span style="display:flex;"><span>                g<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> cnt <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//由于转变了 状态转移条件定义为恰好等于体积m时的 所以需遍历得到 最大价值</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> N;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(res,f<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;=</span> m;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(f<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> res) cnt <span style="color:#f92672">+=</span> g<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(cnt);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="8求背包问题的具体方案">8.求背包问题的具体方案
</h4><p>1.问题描述</p>
<p>2.问题分析：其实判断每个物品是否被选</p>
<p>具体方案 对应最短路</p>
<p>3.代码</p>
<h4 id="9有依赖的背包">9.有依赖的背包
</h4><p>1.问题描述：</p>
<p>有 N 个物品和一个容量是 V 的背包。</p>
<p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p>
<p>如下图所示：
<img src="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png"
	
	
	
	loading="lazy"
	
		alt="QQ图片20181018170337.png"
	
	
></p>
<p>如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。</p>
<p>每件物品的编号是 i，体积是 vi，价值是 wi，依赖的父节点编号是 pi。物品的下标范围是 1…N。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<p>输入格式</p>
<p>第一行有两个整数 N，V，用空格隔开，分别表示物品个数和背包容量。</p>
<p>接下来有 N 行数据，每行数据表示一个物品。
第 行有三个整数 vi,wi,pi用空格隔开，分别表示物品的体积、价值和依赖的物品编号。
如果 pi=−1，表示根节点。 数据保证所有物品构成一棵树。</p>
<p>输出格式</p>
<p>输出一个整数，表示最大价值。</p>
<p>数据范围</p>
<p>1≤N,V≤100
1≤vi,wi≤100</p>
<p>父节点编号范围：</p>
<ul>
<li>内部结点：1≤pi≤N</li>
<li>根节点 pi=−1</li>
</ul>
<p>输入样例</p>
<pre tabindex="0"><code>5 7
2 3 -1
2 2 1
3 5 1
4 7 2
3 6 2
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>11
</code></pre><p>2.问题分析</p>
<p>显然root节点是肯定存在的 因为root是所有子节点的父节点 所以考虑从root节点递归</p>
<p>f[u，j]表示以u为父节点体积不超过j的最大价值。这里不以方案数来划分，以体积划分。（若以方案数：极端情况 99个子节点 需枚举2<!-- raw HTML omitted -->99<!-- raw HTML omitted --> 若以体积量从0~100共101次）。</p>
<p>f[u，j]的第一维代表的是节点，对应树形DP问题；第二维是体积，代表一维分组背包问题</p>
<p>f[u，j]：在”以u为根节点的子树”中选，节点u必选，所选体积不超过j，的所有方案中，价值最大的方案的价值</p>
<p>计算f[u，j]时，先通过分组背包的方式计算在所有孩子节点中选的最大价值，最后再考虑节点u。设节点u有p个孩子节点，那么就相当于有p组物品。</p>
<p>物品组为1∼p，总共可用的体积为m−v[u]现在我们眼中只有p组物品，先不考虑父亲节点，只考虑计算这p组物品的最大价值</p>
<p>根据分组背包的做法，首先枚举物品组，也就是节点u的某个孩子son，对应代码的for (int i = h[u]; i != -1; i = ne[i])</p>
<p>其次枚举体积j，也就是考虑在1∼son的物品组中选，所选体积不超过jj的最大价值。
最后枚举在物品组son中选体积为k的物品，k∈[0,j]，因为1∼son的物品组一共选了不超过j的体积</p>
<p>状态转移是f[u，j] = max(f[u，j], f[u，j - k] + f[son，k])。</p>
<p>f[u，j] 由于体积j是从大到小枚举，所以这里f[u，j-k]表示在1∼son−1的物品组中选，体积不超过j−k的方案的最大价值，这里省略了表示”在1∼son−1的物品组中选”的维度，相当于一维的分组背包。而f[u，j]的第一维代表的不是背包问题，而是树形DP，第二维代表的才是分组背包。所以这道题是树形DP和背包的综合。</p>
<p>f[son，k]: 由于状态转移之前已经递归调用了dfs(son)，所以以son为根的子树已经计算好了。f[son，k]表示在以son为根的子树中选，所选体积不超过kk的最大价值
综上，f[u，j−k]+f[son，k]的前半部分更趋向于分组背包，后半部分趋向于树形DP</p>
<p>计算完f[u，* ]之后，f[u， *]代表的其实是在节点u的所有子树1∼p中选的最大价值，没有计算u的价值，所以需要加上最后的两个for循环</p>
<p>3.代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 110;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> n,m,idx;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//表示第i个节点中选(i这个父节点以及他的所有子节点)，总体积不超过j的方法的最大值</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> v <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//体积</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> w <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//价值</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> h <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>,e <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>,ne <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>        e<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>        ne<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> h<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        h<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> idx<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//u表示父节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h<span style="color:#f92672">[</span>u<span style="color:#f92672">]</span>;i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1 ; i <span style="color:#f92672">=</span> ne<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//类似于分组背包 先遍历不同组 每个父节点下的子节点可看作一组 可以将头节点h[a]看作一组的标号</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> son <span style="color:#f92672">=</span> e<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;<span style="color:#75715e">//遍历子节点</span>
</span></span><span style="display:flex;"><span>            dfs(son);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//因为父节点是要保留的，所以我们的体积要预留出来放父节点的位置，d = m - v[u]</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//然后这里为什么从大到小枚举体积，类似01背包，这里被优化了一重循环，空间优化掉了，本来是三位的定义f[][][]</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m <span style="color:#f92672">-</span> v<span style="color:#f92672">[</span>u<span style="color:#f92672">]</span>; j <span style="color:#f92672">&gt;=</span> 0 ; j <span style="color:#f92672">--</span> ){<span style="color:#75715e">//循环体积</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> 0 ; k <span style="color:#f92672">&lt;=</span> j ; k <span style="color:#f92672">++</span> ){ <span style="color:#75715e">// 然后枚举决策，子节点只要不超过我们预留了父节点之后的体积d</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//这一个节点的最大值，就等于预留了能够放父节点之后剩余的体积d里面，</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//在子节点中挑能够满足不超过d 并且 选择不超过且最大的子节点体积</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//f[u][j - k] + f[son][k] 这个的意思是加上这个f[son][k]儿子之后空间还有多少会不会超过了，</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//但是我们已经限制了k比总体积小，所以永远不会超过，所以这个子节点一定是可以选择的</span>
</span></span><span style="display:flex;"><span>                    f<span style="color:#f92672">[</span>u<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(f<span style="color:#f92672">[</span>u<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>u<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> k<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> f<span style="color:#f92672">[</span>son<span style="color:#f92672">][</span>k<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//这个是我们的父节点，所以需要存下来的，体积要大于我们的父节点才能够存下来</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//f[u][i - v[u]] +  w[u] 这个的意思是上面dfs中我们预留了父节点位置剩余的d在这一节点中子节点能够选择的最大价值</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//然后再加上我们的父节点的价值，f[u][i]就是我们现在这一整个节点中的最大价值</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> m ; i <span style="color:#f92672">&gt;=</span> v<span style="color:#f92672">[</span>u<span style="color:#f92672">]</span>; i <span style="color:#f92672">--</span> ) f<span style="color:#f92672">[</span>u<span style="color:#f92672">][</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> f<span style="color:#f92672">[</span>u<span style="color:#f92672">][</span>i <span style="color:#f92672">-</span> v<span style="color:#f92672">[</span>u<span style="color:#f92672">]]</span> <span style="color:#f92672">+</span>  w<span style="color:#f92672">[</span>u<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">//这个是不满足的情况，因为剩余的体积连放根节点都不够，所以这种情况不存在，直接赋值成0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0 ; i <span style="color:#f92672">&lt;</span> v<span style="color:#f92672">[</span>u<span style="color:#f92672">]</span> ; i <span style="color:#f92672">++</span> ) f<span style="color:#f92672">[</span>u<span style="color:#f92672">][</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner scan <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();<span style="color:#75715e">//n个节点</span>
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();<span style="color:#75715e">//总体积</span>
</span></span><span style="display:flex;"><span>        Arrays.<span style="color:#a6e22e">fill</span>(h,<span style="color:#f92672">-</span>1);<span style="color:#75715e">//初始化所有父节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> root <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1 ; i <span style="color:#f92672">&lt;=</span> n ; i <span style="color:#f92672">++</span> ){
</span></span><span style="display:flex;"><span>            v<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();<span style="color:#75715e">//体积</span>
</span></span><span style="display:flex;"><span>            w<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();<span style="color:#75715e">//价值</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> scan.<span style="color:#a6e22e">nextInt</span>();<span style="color:#75715e">//依赖的父节点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1){
</span></span><span style="display:flex;"><span>                root <span style="color:#f92672">=</span> i;<span style="color:#75715e">//表示i这个节点是父节点</span>
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                add(p,i);<span style="color:#75715e">//表示p到i连一条有向边,p是父节点</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        dfs(root);<span style="color:#75715e">//从根节点开始递归</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//最后按照定义输出，根节点这一节点中选，总体积不超过m的最大价值</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(f<span style="color:#f92672">[</span>root<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2线性dp">2.线性DP
</h3><h4 id="1数字三角形">1.数字三角形
</h4><p>1.问题描述：给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p>
<pre tabindex="0"><code>        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
</code></pre><p>输入格式</p>
<p>第一行包含整数 n，表示数字三角形的层数。</p>
<p>接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。</p>
<p>输出格式</p>
<p>输出一个整数，表示最大的路径数字和。</p>
<p>数据范围</p>
<p>1≤n≤500,
−10000≤三角形中的整数≤10000</p>
<p>输入样例：</p>
<pre tabindex="0"><code>5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>30
</code></pre><p>2.问题分析</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR;
   A[Dp]--&gt;B[状态表示]
   A--&gt;C[状态计算]	
   B--&gt;D[集合]
   B--&gt;E[属性:Max]
   
   
</code></pre><p>先对该数字三角形进行二维定义</p>
<pre tabindex="0"><code>
              1
1-----------7   2
2---------3   8   3
3-------8   1   0   4
4-----2   7   4   4   5
5---4   5   2   6   5   
</code></pre><p>对第i行计为i行1 对第j条斜线 计为第j列 对于状态表示：f[i] [j] 表示所有从起点到元素[i] [j]的最大路径。</p>
<p>其中f[i] [j]=Max{从左上角下来的路线，从右上角下来的路线}=Max{f[i-1] [j-1]+a[i] [j], f[i-1] [j]+a[i] [j]}</p>
<p>ps：小技巧 如果下标有i-1 那么最好从i=1开始 可以少一些判断 同时动态规划的时间复杂度计算一般为 T(状态数量* 转移数量)</p>
<p>3.代码</p>
<p>[法一]自顶向下 最后需求所有最低端的最大值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">510</span>,INF<span style="color:#f92672">=</span><span style="color:#ae81ff">1e9</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[N][N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f[N][N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>i;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>a[i][j]);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//需将元素初始化为负无穷 由于数组元素默认为0 而路径上的元素可能为负
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//还有要将初始化时多一点 将i j从0开始 还有将j的最大扩展至i+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//比如对于斜边上的元素他们的左上方或右上方是不存在元素的 如果不初始化可能和为0大于右上方或左上方路径之和负数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			f[i][j]<span style="color:#f92672">=-</span>INF;
</span></span><span style="display:flex;"><span>	f[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>a[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>i;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			f[i][j]<span style="color:#f92672">=</span>max(f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>a[i][j],f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">+</span>a[i][j]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> res<span style="color:#f92672">=-</span>INF;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) res<span style="color:#f92672">=</span>max(res,f[n][i]);
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">&#34;%d&#34;</span>,res);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>[法二]自下向最顶层 最后汇聚至第一个元素</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">510</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[N][N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f[N][N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>i;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>a[i][j]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>n;j<span style="color:#f92672">++</span>) f[n][j]<span style="color:#f92672">=</span>a[n][j]; 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>i;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			f[i][j]<span style="color:#f92672">=</span>max(f[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>a[i][j],f[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">+</span>a[i][j]);
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">&#34;%d&#34;</span>,f[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不用初始化 保证了每一个元素的左下和右下必有元素</p>
<h4 id="2最长上升子序列">2.最长上升子序列
</h4><p>1.问题描述</p>
<p>给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</p>
<p>输入格式</p>
<p>第一行包含整数 N。第二行包含 N 个整数，表示完整序列。</p>
<p>输出格式</p>
<p>输出一个整数，表示最大长度。</p>
<p>数据范围</p>
<p>1≤N≤1000，−10<!-- raw HTML omitted -->9<!-- raw HTML omitted -->≤数列中的数≤10<!-- raw HTML omitted -->9<!-- raw HTML omitted --></p>
<p>输入样例：</p>
<pre tabindex="0"><code>7
3 1 2 1 8 5 6
//挑1 2 5 6得到4
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>4
</code></pre><p>2.问题分析</p>
<p>Dp问题先考虑能用什么维度来表示状态 如果有是否可以简化维数 对于时间复杂度而言每简化一维就少一维</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR;
	A[Dp]--&gt;B[状态表示]
	A--&gt;C[状态计算]	
	B--&gt;D[集合]
	B--&gt;E[属性:Max]
</code></pre><p>这里可用一维来记录状态 f[i]表示所有以第i个数结尾的上升子序列的长度最大值(所以这里的定义已确定结尾一定为i)</p>
<p>这里已经假设f[i]=以a[i]结尾的数的上升子序列长度最大值=(if a[j]&lt;=a[i] )Max(f[0],f[1]，&hellip;.f[j],&hellip;.f[i-1])+1</p>
<p>3.代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">1010</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[N],f[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>a[i]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//先初始化f[i]即若前面的所有元素都不满足a[j]&lt;a[i]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		f[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//利用循环不断更新f[i]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;</span>i;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(a[j]<span style="color:#f92672">&lt;</span>a[i]) f[i]<span style="color:#f92672">=</span>max(f[i],f[j]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//利用循环找到以a[i]结尾的最大长度的上升子序列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> res<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) res<span style="color:#f92672">=</span>max(res,f[i]);
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,res);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>时间复杂度T(n<!-- raw HTML omitted -->2<!-- raw HTML omitted -->)</p>
<p>保存序列具体数据：</p>
<p>最长上升子序列II 数据范围为1≤N≤100000 会超时</p>
<p>贪心法求解</p>
<p>对于一个序列 认为一个数a<!-- raw HTML omitted -->i<!-- raw HTML omitted --> &gt; a<!-- raw HTML omitted -->j<!-- raw HTML omitted --> (i &gt; j)那么能接在a<!-- raw HTML omitted -->i<!-- raw HTML omitted -->后面的数一定能接在a<!-- raw HTML omitted -->j<!-- raw HTML omitted -->后面  （有些序列便不必存储下来）可以发现长度为1~k的上升子序列的末尾数一定是上升的 否则 必然会从长度更大的子序列中找到一个数填进长度更小的序列 于是进行替换</p>
<p>遍历每个数  然后二分求解到小于该数的最大值 O(nlogn)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 100010,n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> q <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//所有不同长度子序列末尾最小值的那个子序列的末尾数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>) a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> 0;<span style="color:#75715e">//q里的元素个数</span>
</span></span><span style="display:flex;"><span>        q<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">-</span>2e9;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> 0,r <span style="color:#f92672">=</span> len;<span style="color:#75715e">//从len个子序列中找比a[i]小的最大子序列</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(l <span style="color:#f92672">&lt;</span> r)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">+</span> 1 <span style="color:#f92672">&gt;&gt;</span> 1;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(q<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>) l <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            len <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(len,r <span style="color:#f92672">+</span> 1);<span style="color:#75715e">//看是否会新增一列长度没出现过的子序列</span>
</span></span><span style="display:flex;"><span>            q<span style="color:#f92672">[</span>r <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;<span style="color:#75715e">//并替换成末尾更小的一个数</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(len);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3最长公共子序列">3.最长公共子序列
</h4><p>1.问题描述</p>
<p>给定两个长度分别为 N和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p>
<p>输入格式</p>
<p>第一行包含两个整数 N 和 M。</p>
<p>第二行包含一个长度为 N 的字符串，表示字符串 A。</p>
<p>第三行包含一个长度为 M 的字符串，表示字符串 B。</p>
<p>字符串均由小写字母构成。</p>
<p>输出格式</p>
<p>输出一个整数，表示最大长度。</p>
<p>数据范围</p>
<p>1≤N,M≤1000</p>
<p>输入样例：</p>
<pre tabindex="0"><code>4 5
acbd
abedc
//abd即为所求
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>3
</code></pre><p>2.问题分析</p>
<p>集合可表示为 在第一个子序列前i个元素和第二个子序列前j个元素相同的最长子序列</p>
<p>集合划分：首先考虑第一个序列中的前i个字母中的最后一个a[i]和第二个序列中的前j个字母中的最后一个b[j]  二者有选或不选 故划分成三份。</p>
<p>1）对于第a[i]选和b[j]不选的情况 可表示为f[i, j-1]（其实不是这样 还包括了不选第a[i]个 但是由于求最大值故可包括）</p>
<p>2）对于第a[i]不选和b[j]选的情况 可表示为f[i-1, j]（其实不是这样 还包括了不选第b[j]个 但是由于求最大值故可包括）</p>
<p>3）对于a[i]和b[j]都选上的情况 可表示为f[i-1, j-1]+1（对于此情况来说a[i]和b[i]为匹配的子序列的最后一个数）</p>
<p>3.代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1010,n,m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        String s1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> sc.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>        String s2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> sc.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> s1.<span style="color:#a6e22e">toCharArray</span>();
</span></span><span style="display:flex;"><span>        b <span style="color:#f92672">=</span> s2.<span style="color:#a6e22e">toCharArray</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 1;j <span style="color:#f92672">&lt;=</span> m;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(f<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> b<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>) f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(f<span style="color:#f92672">[</span>n<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="4最短编辑距离">4.最短编辑距离
</h4><p>1.问题描述：给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：</p>
<ol>
<li>删除–将字符串 A 中的某个字符删除。</li>
<li>插入–在字符串 A 的某个位置插入某个字符。</li>
<li>替换–将字符串 A 中的某个字符替换为另一个字符。</li>
</ol>
<p>现在请你求出，将 A 变为 B 至少需要进行多少次操作。</p>
<p>输入格式</p>
<p>第一行包含整数 n，表示字符串 A 的长度。</p>
<p>第二行包含一个长度为 n 的字符串 A。</p>
<p>第三行包含整数 m，表示字符串 B 的长度。</p>
<p>第四行包含一个长度为 m 的字符串 B。</p>
<p>字符串中均只包含大小写字母。</p>
<p>输出格式</p>
<p>输出一个整数，表示最少操作次数。</p>
<p>数据范围</p>
<p>1≤n,m≤1000</p>
<p>输入样例：</p>
<pre tabindex="0"><code>10 
AGTCTGACGC
11 
AGTAAGTAGGC
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>4
</code></pre><p>2.思路：考虑最后一次插入、删除或修改。f（i，j）表示 A序列前i个数的操作f[i] [j]次之后和B序列的前j号数相等</p>
<p>每次操作为只操作第i号数 插入f[i] [j - 1] + 1、删除f[i - 1] [j] + 1、修改 f[i - 1] [j - 1] + 1/0(如果相等可以不修改则加0)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 1010,n,m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        String str1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> sc.<span style="color:#a6e22e">next</span>();    
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> str1.<span style="color:#a6e22e">toCharArray</span>();
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        String str2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> sc.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>        b <span style="color:#f92672">=</span> str2.<span style="color:#a6e22e">toCharArray</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//初始化 </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>) f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> m;i <span style="color:#f92672">++</span>) f<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 1;j <span style="color:#f92672">&lt;=</span> m;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">min</span>(f<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>) <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> b<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>) f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">min</span>(f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">min</span>(f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(f<span style="color:#f92672">[</span>n<span style="color:#f92672">][</span>m<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="5最大连续子序列">5.最大连续子序列
</h4><p>保证在O(n)的情况下完成，用其他状态转移方程会超时</p>
<p>集合划分：以i结尾的子序列的最大值：1）只包含i，即f[i] = w[i] 2）还有其他数，即0<del>i,1</del>i,2<del>i,&hellip;i -1</del>i ——&gt;f[i] = f[i - 1] + w[i]</p>
<h3 id="3区间dp">3.区间DP*
</h3><p><strong>注意：区间DP的计算顺序可能不同于其他DP，所以需确定好一个计算顺序，保证后面所需要的状态 已经在前面计算。如在石子合并中，先计算最小区间的状态，即从length=2开始计算</strong></p>
<p>涵盖四个方面：环形问题、二维区间DP、记录方案数、区间Dp+高精度</p>
<h4 id="石子合并问题">石子合并问题*
</h4><p>一维形式</p>
<p>1.问题描述：设有 N 堆石子排成一排，其编号为 1，2，3，…，N。</p>
<p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。</p>
<p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>例如有 4 堆石子分别为 <code>1 3 5 2</code>， 我们可以先合并 1、2堆，代价为 4，得到 <code>4 5 2</code>， 又合并 1，2堆，代价为 9，得到 <code>9 2</code> ，再合并得到 11，总代价为 4+9+11=24；</p>
<p>如果第二步是先合并 2，3 堆，则代价为 7，得到 <code>4 7</code>，最后一次合并代价为 11，总代价为 4+7+11=22。</p>
<p>问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p>
<p>输入格式</p>
<p>第一行一个数 N 表示石子的堆数 N。</p>
<p>第二行 N个数，表示每堆石子的质量(均不超过 1000)。</p>
<p>输出格式</p>
<p>输出一个整数，表示最小代价。</p>
<p>数据范围</p>
<p>1≤N≤300</p>
<p>输入样例：</p>
<pre tabindex="0"><code>4
1 3 5 2
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>22
</code></pre><p>2.问题分析</p>
<p>如果暴力求解 枚举次数为（n - 1）!</p>
<p>状态表示f[i] [j]为从第i号数到第j号数的最小合并代价 划分为按第k个数将一堆数划分为两堆k = i,i + 1,&hellip;.,j - 1</p>
<p>则f[i] [j] = f[i] [k] + f[k + 1] [j] + s[j] - s[i - 1]（还要包括最后一次将这堆数合并起来的代价）</p>
<p>3.代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 310,n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            s<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> 2;len <span style="color:#f92672">&lt;=</span> n;len <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">+</span> len <span style="color:#f92672">-</span> 1 <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> i,r <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> len <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>                f<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0x3f3f3f3f;<span style="color:#75715e">//不能直接在最外层循环赋值 否则f[l][k],f[k + 1][r]为正无穷 实际当左右相等应为0</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> l;k <span style="color:#f92672">&lt;</span> r;k <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                    f<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">min</span>(f<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> f<span style="color:#f92672">[</span>k <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> s<span style="color:#f92672">[</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> s<span style="color:#f92672">[</span>l <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(f<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>n<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 310,n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> q <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span> ){
</span></span><span style="display:flex;"><span>            q<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            s<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> q<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> N;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> N;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">!=</span> j) f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0x3f3f3f3f;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> 2;len <span style="color:#f92672">&lt;=</span> n;len <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">+</span> len <span style="color:#f92672">-</span> 1<span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> len <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> i;k <span style="color:#f92672">&lt;</span> j;k <span style="color:#f92672">++</span>) 
</span></span><span style="display:flex;"><span>                    f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">min</span>(f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> f<span style="color:#f92672">[</span>k <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> s<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> s<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(f<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>n<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>环形形式</p>
<p>将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。</p>
<p>规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。</p>
<p>请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算：</p>
<ul>
<li>选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。</li>
<li>选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。</li>
</ul>
<p>输入格式</p>
<p>第一行包含整数 n，表示共有 n 堆石子。</p>
<p>第二行包含 n 个整数，分别表示每堆石子的数量。</p>
<p>输出格式</p>
<p>输出共两行：</p>
<p>第一行为合并得分总和最小值，</p>
<p>第二行为合并得分总和最大值。</p>
<p>数据范围</p>
<p>1≤n≤200</p>
<p>输入样例：</p>
<pre tabindex="0"><code>4
4 5 9 4
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>43
54
</code></pre><p>思路：考虑到是一个圆形 如果要合并成一堆至少在点与点之间连接n - 1条线 最后可以变成最后只有两个点没有连线</p>
<p>这里可以考虑枚举这个空挡n种 则有n * n<!-- raw HTML omitted -->3<!-- raw HTML omitted --> 超时 则考虑 把项链拉直比如有5个点 1、2、3、4、5</p>
<p>则变为1、2、3、4、5、1、2、3、4、5 则求值维度为（2n）<!-- raw HTML omitted -->3<!-- raw HTML omitted --> 此方法适用于所有环形问题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 410,n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> w <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;<span style="color:#75715e">//代表左右端点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> g <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>            Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                w<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>                w<span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> n<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> w<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;<span style="color:#75715e">//把环形拉成链</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//处理出前缀和</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> 2 <span style="color:#f92672">*</span> n;i <span style="color:#f92672">++</span> ) s<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> w<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> N;i <span style="color:#f92672">++</span> ) Arrays.<span style="color:#a6e22e">fill</span>(f<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>,<span style="color:#f92672">-</span>0x3f3f3f3f);<span style="color:#75715e">//求最大值</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> N;i <span style="color:#f92672">++</span> ) Arrays.<span style="color:#a6e22e">fill</span>(g<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>,0x3f3f3f3f);<span style="color:#75715e">//求最小值</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//迭代式求解</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> 1;len <span style="color:#f92672">&lt;=</span> n;len <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> 1;l <span style="color:#f92672">+</span> len <span style="color:#f92672">-</span> 1 <span style="color:#f92672">&lt;=</span> 2 <span style="color:#f92672">*</span> n;l <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> len <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span>(len <span style="color:#f92672">==</span> 1) g<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> f<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">//如果len == 1 无法进入下层循环 如果把赋值为0放进去没用</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> l;k <span style="color:#f92672">&lt;</span> l <span style="color:#f92672">+</span> len <span style="color:#f92672">-</span> 1;k <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                            f<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(f<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> f<span style="color:#f92672">[</span>k <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> s<span style="color:#f92672">[</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> s<span style="color:#f92672">[</span>l <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>                            g<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">min</span>(g<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span>,g<span style="color:#f92672">[</span>l<span style="color:#f92672">][</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> g<span style="color:#f92672">[</span>k <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> s<span style="color:#f92672">[</span>r<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> s<span style="color:#f92672">[</span>l <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                    
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> minv <span style="color:#f92672">=</span> 0x3f3f3f3f,maxv <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>0x3f3f3f3f;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                maxv <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(maxv,f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>i <span style="color:#f92672">+</span> n <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>                minv <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">min</span>(minv,g<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>i <span style="color:#f92672">+</span> n <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(minv);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(maxv);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="能量项链">能量项链*
</h4><h3 id="4计数dp">4.计数DP
</h3><h3 id="5数位统计">5.数位统计
</h3><p>多是分类讨论计数 类比于 0<del>9 10</del>99 100~999</p>
<h3 id="6状态压缩dp">6.状态压缩DP
</h3><p>用集合或2进制表的形式表示状态（类比于状态机 状态机以时序的方式来表示状态）</p>
<p>分为两大类</p>
<ul>
<li>棋盘式（基于连通性）</li>
<li>集合式（看是否在集合中）</li>
</ul>
<h5 id="蒙德里安的梦想">蒙德里安的梦想
</h5><p>求把 N×M 的棋盘分割成若干个 1×2 的长方形，有多少种方案。</p>
<p>例如当 N=2，M=4时，共有 5 种方案。当 N=2，M=3 时，共有 3 种方案。</p>
<p>如下图所示：</p>
<p><img src="https://www.acwing.com/media/article/image/2019/01/26/19_4dd1644c20-2411_1.jpg"
	
	
	
	loading="lazy"
	
		alt="2411_1.jpg"
	
	
></p>
<p>输入格式</p>
<p>输入包含多组测试用例。</p>
<p>每组测试用例占一行，包含两个整数 N 和 M。</p>
<p>当输入用例 N=0，M=0时，表示输入终止，且该用例无需处理。</p>
<p>输出格式</p>
<p>每个测试用例输出一个结果，每个结果占一行。</p>
<p>数据范围</p>
<p>1≤N,M≤11</p>
<p>输入样例：</p>
<pre tabindex="0"><code>1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>1
0
1
2
3
5
144
51205
</code></pre><p>思路：考虑先将横着的方块摆完 剩下的放竖着的 用0 1来表示每一列的状态 1表示这行有一块横放的方块</p>
<p>f[i,j]表示为第i列的状态为j的满足题意的数量  其中要求每一列的挨着的空白格的数量必须为偶数且前后两列不能有重叠的方块</p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//将横放的摆完 剩下的放竖着的</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 12,M <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 11;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> st <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>M<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">[][]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>M<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#66d9ef">true</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">==</span> 0) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> 1 <span style="color:#f92672">&lt;&lt;</span> n;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//开始枚举2^n个状态</span>
</span></span><span style="display:flex;"><span>                st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> n;j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span>(((i <span style="color:#f92672">&gt;&gt;</span> j) <span style="color:#f92672">&amp;</span> 1) <span style="color:#f92672">==</span> 1)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span>((cnt <span style="color:#f92672">%</span> 2) <span style="color:#f92672">==</span> 1) st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                        cnt <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span> cnt <span style="color:#f92672">++</span>;<span style="color:#75715e">//当前连续0的个数</span>
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">if</span>((cnt <span style="color:#f92672">%</span> 2) <span style="color:#f92672">==</span> 1) st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            f<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)1;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> m;i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> (1 <span style="color:#f92672">&lt;&lt;</span> n);j <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> 0;k <span style="color:#f92672">&lt;</span> (1 <span style="color:#f92672">&lt;&lt;</span> n);k <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">//保证一列中间隔数为偶数 前后列没有重合</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span>((j <span style="color:#f92672">&amp;</span> k) <span style="color:#f92672">==</span> 0 <span style="color:#f92672">&amp;&amp;</span> st<span style="color:#f92672">[</span>j <span style="color:#f92672">|</span> k<span style="color:#f92672">]</span>) f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> f<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>k<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                        
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(f<span style="color:#f92672">[</span>m<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> N;i <span style="color:#f92672">++</span> ) Arrays.<span style="color:#a6e22e">fill</span>(f<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>,0);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="最短hamilton路径">最短Hamilton路径
</h5><p>给定一张 n个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1 的最短 Hamilton 路径。</p>
<p>Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。</p>
<p>输入格式</p>
<p>第一行输入整数 n。</p>
<p>接下来 n 行每行 n 个整数，其中第 i 行第 j 个整数表示点 i 到 j 的距离（记为 a[i,j]）。</p>
<p>对于任意的 x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]≥a[x,z]。</p>
<p>输出格式</p>
<p>输出一个整数，表示最短 Hamilton 路径的长度。</p>
<p>数据范围</p>
<p>1≤n≤20</p>
<p>0≤a[i,j]≤10<!-- raw HTML omitted -->7<!-- raw HTML omitted --></p>
<p>输入样例：</p>
<pre tabindex="0"><code>5
0 2 4 5 1
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>18
</code></pre><p>思路：不同于最短路在于 不重不漏 且起点为0 终点为n - 1</p>
<p>如果考虑暴力枚举 需要20！来枚举路径</p>
<p>这里用f[i , j]表示走过了i的状态（如走过了第0，1，4则i = 10011）且正走到第j号点</p>
<p>枚举倒数第二个点是什么来分类k（k = 0、1、2&hellip;n - 1）f[i,j] = f[i - {j},k] + w(k,j)</p>
<p>代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 21,n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> g <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>1 <span style="color:#f92672">&lt;&lt;</span> N<span style="color:#f92672">][</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> n;j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>                g<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> (1 <span style="color:#f92672">&lt;&lt;</span> N);i <span style="color:#f92672">++</span>) Arrays.<span style="color:#a6e22e">fill</span>(f<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>,0x3f3f3f3f);
</span></span><span style="display:flex;"><span>        f<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0; <span style="color:#75715e">//先把0号点放入集合</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> (1 <span style="color:#f92672">&lt;&lt;</span> n);i <span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;j <span style="color:#f92672">&lt;</span> n;j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(((i <span style="color:#f92672">&gt;&gt;</span> j) <span style="color:#f92672">&amp;</span> 1) <span style="color:#f92672">==</span> 1)<span style="color:#75715e">//首先保证j在i中</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> 0;k <span style="color:#f92672">&lt;</span> n;k <span style="color:#f92672">++</span>)<span style="color:#75715e">//枚举倒数第二个点k</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span>((((i <span style="color:#f92672">-</span> (1 <span style="color:#f92672">&lt;&lt;</span> j)) <span style="color:#f92672">&gt;&gt;</span> k) <span style="color:#f92672">&amp;</span> 1) <span style="color:#f92672">==</span> 1)<span style="color:#75715e">//保证减去j后 k也在i中</span>
</span></span><span style="display:flex;"><span>                            f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">min</span>(f<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> (1 <span style="color:#f92672">&lt;&lt;</span> j)<span style="color:#f92672">][</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> g<span style="color:#f92672">[</span>k<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>                            
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(f<span style="color:#f92672">[</span>(1 <span style="color:#f92672">&lt;&lt;</span> n) <span style="color:#f92672">-</span> 1<span style="color:#f92672">][</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span>);     
</span></span><span style="display:flex;"><span>    }   
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="7树形dp">7.树形DP
</h3><p>类似于状态机</p>
<h4 id="没有上司的舞会">没有上司的舞会
</h4><p>题目描述：Ural 大学有 NN 名职员，编号为 1∼N。</p>
<p>他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。</p>
<p>每个职员有一个快乐指数，用整数 Hi 给出，其中1≤i≤N。</p>
<p>现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。</p>
<p>在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。</p>
<p>输入格式</p>
<p>第一行一个整数 N。</p>
<p>接下来 N 行，第 i 行表示 i号职员的快乐指数 Hi。</p>
<p>接下来 N−1 行，每行输入一对整数 L,K，表示 K 是 L 的直接上司。</p>
<p>输出格式</p>
<p>输出最大的快乐指数。</p>
<p>数据范围</p>
<p>1≤N≤6000	−128≤Hi≤127</p>
<p>输入样例：</p>
<pre tabindex="0"><code>7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>5
</code></pre><p>思路：以f(u,0)、f(u,1)分别表示以u为根节点不取u和取u的最大化收益</p>
<p>f(u,0) = Max(f(t1,0),f(t1,1)) + Max(f(t2,0),f(t2,1))+&hellip;.;f(u,1) = f(t1,0) + f(t2,0)+&hellip;;（t1、t2..等为u的所有子节点）</p>
<p>故先求出所有子节点的状态 时间复杂度为O(n)每个子节点只算一遍</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 60010,n,idx;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> happy <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> h <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> ne <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> e <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> has_father <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>N<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>        Scanner sc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner(System.<span style="color:#a6e22e">in</span>);
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1;i <span style="color:#f92672">&lt;=</span> n;i <span style="color:#f92672">++</span>)  happy<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//初始化h所有指针都指向-1</span>
</span></span><span style="display:flex;"><span>        Arrays.<span style="color:#a6e22e">fill</span>(h,<span style="color:#f92672">-</span>1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> 1;i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> sc.<span style="color:#a6e22e">nextInt</span>();
</span></span><span style="display:flex;"><span>            has_father<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            add(b,a);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//计算根节点 因为是有向图（有上司和下属的关系）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> root <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(has_father<span style="color:#f92672">[</span>root<span style="color:#f92672">]</span>) root <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        dfs(root);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(Math.<span style="color:#a6e22e">max</span>(f<span style="color:#f92672">[</span>root<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>root<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>        f<span style="color:#f92672">[</span>u<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> happy<span style="color:#f92672">[</span>u<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h<span style="color:#f92672">[</span>u<span style="color:#f92672">]</span>;i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1;i <span style="color:#f92672">=</span> ne<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            dfs(j);
</span></span><span style="display:flex;"><span>            f<span style="color:#f92672">[</span>u<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> Math.<span style="color:#a6e22e">max</span>(f<span style="color:#f92672">[</span>j<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span>,f<span style="color:#f92672">[</span>j<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            f<span style="color:#f92672">[</span>u<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> f<span style="color:#f92672">[</span>j<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>        e<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>        ne<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> h<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        h<span style="color:#f92672">[</span>a<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="8记忆化搜索">8.记忆化搜索
</h3><p>以递归的方式求解状态 一定不能存在环</p>
<h3 id="9状态机">9.状态机
</h3><p>简单定义：把不好直接表示的状态分为几个状态来表示并其之间能够转换</p>
<p>问题：大盗阿福</p>
<p>问题描述：</p>
<p>传统思路：f[ i ]前i个店铺的最大收益 f[ i ] = max(f[i  - 2] + w[ i ],f[i - 1])</p>
<p>状态机：把每个f[ i ]分解为0（未选） 1（选择）两个状态</p>
<p>f[i ，0] = Math.max(f[i - 1 ，0],f[i - 1 ，1]);</p>
<p>f[i ，1] = f[ i - 1 ，0] + w[i];</p>
<h2 id="6贪心">6.贪心
</h2><p>对于贪心 一般没有套路和固定模板 可自己先尝试据部分例子 摸索出一套算法 最后证明即可</p>
<p>贪心问题 每次（每一步）只选择看眼前看起来最优的情况（当前最优解） 比较短视</p>
<p>总的来说 贪心问题最优解 必为单峰函数（最终会走到最大点） 若为多峰 可能只会走到其中一极值</p>
<p>最后证明算法正确性</p>
<h4 id="1区间选点">1.区间选点
</h4><p>1.问题描述：</p>
<p>给定 N 个闭区间 [a<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,b<!-- raw HTML omitted -->i<!-- raw HTML omitted -->]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。</p>
<p>输出选择的点的最小数量。</p>
<p>位于区间端点上的点也算作区间内。</p>
<p>输入格式</p>
<p>第一行包含整数 N，表示区间数。</p>
<p>接下来 N 行，每行包含两个整数 a<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,b<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，表示一个区间的两个端点。</p>
<p>输出格式</p>
<p>输出一个整数，表示所需的点的最小数量。</p>
<p>数据范围</p>
<p>1≤N≤10<!-- raw HTML omitted -->5<!-- raw HTML omitted -->,
−10<!-- raw HTML omitted -->9<!-- raw HTML omitted -->≤a<!-- raw HTML omitted -->i<!-- raw HTML omitted -->≤b<!-- raw HTML omitted -->i<!-- raw HTML omitted -->≤10<!-- raw HTML omitted -->9<!-- raw HTML omitted --></p>
<p>输入样例：</p>
<pre tabindex="0"><code>3
-1 1
2 4
3 5
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>2
</code></pre><p>2.问题分析</p>
<p>//一般区间问题先排序 可按右端点从小到大排序 从前往后一次枚举每个区间</p>
<p>//尽可能选最右的点以便覆盖更多的区间</p>
<p>//如果当前区间中已经包含点，则直接pass 否则选择当前区间最右端点</p>
<p>//证明正确性 可行解=最优解</p>
<p>数学中常用判等手法 A&lt;=B;A&gt;=B==》A=B</p>
<p>最坏情况 每个区间两两都不相交 每个区间</p>
<p>还有一种情况？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？</p>
<p>3.代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include&lt;algorithm&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span><span style="color:#ae81ff">100010</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//定义一个结构 包含左右端点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Range</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> l,r;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//重载小于号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> Range <span style="color:#f92672">&amp;</span>w)<span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> r <span style="color:#f92672">&lt;</span> w.r; 
</span></span><span style="display:flex;"><span>	} 
</span></span><span style="display:flex;"><span>}range[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> l,r;
</span></span><span style="display:flex;"><span>		scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>l,<span style="color:#f92672">&amp;</span>r);
</span></span><span style="display:flex;"><span>		range[i] <span style="color:#f92672">=</span> {l,r};
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//按右端点排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sort(range,range<span style="color:#f92672">+</span>n);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//res用来计数 ed为上一个点坐标 初值为负无穷
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> res<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,ed<span style="color:#f92672">=-</span><span style="color:#ae81ff">2e9</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i<span style="color:#f92672">++</span>) 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//倘若上一个点没在该区间内则 res+1 否则continue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(range[i].l<span style="color:#f92672">&gt;</span>ed){
</span></span><span style="display:flex;"><span>			res<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			ed<span style="color:#f92672">=</span>range[i].r;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	cout<span style="color:#f92672">&lt;&lt;</span>res<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2最大不相交区间数量">2.最大不相交区间数量
</h4><p>1.问题描述</p>
<p>给定 N 个闭区间 [a<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,b<!-- raw HTML omitted -->i<!-- raw HTML omitted -->]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。</p>
<p>输出可选取区间的最大数量。</p>
<p>输入格式</p>
<p>第一行包含整数 N，表示区间数。</p>
<p>接下来 N 行，每行包含两个整数 a<!-- raw HTML omitted -->i<!-- raw HTML omitted -->,b<!-- raw HTML omitted -->i<!-- raw HTML omitted -->，表示一个区间的两个端点。</p>
<p>输出格式</p>
<p>输出一个整数，表示可选取区间的最大数量。</p>
<p>数据范围</p>
<p>1≤N≤10<!-- raw HTML omitted -->5<!-- raw HTML omitted -->,
−10<!-- raw HTML omitted -->9<!-- raw HTML omitted -->≤a<!-- raw HTML omitted -->i<!-- raw HTML omitted -->≤b<!-- raw HTML omitted -->i<!-- raw HTML omitted -->≤10<!-- raw HTML omitted -->9<!-- raw HTML omitted --></p>
<p>输入样例：</p>
<pre tabindex="0"><code>3
-1 1
2 4
3 5
</code></pre><p>输出样例：</p>
<pre tabindex="0"><code>2
</code></pre><p>2.问题分析</p>
<p>//第一题：一个点尽可能占更多空间 第二题：希望更多的空间不相交   意思一样（？？？？？？？？？？？？？？？？？？？？</p>
<p>原理分析后同上</p>
<p>证明正确性</p>
<p>3.代码</p>
<h2 id="7时空复杂度分析">7.时空复杂度分析
</h2><p>参考蓝桥杯课程第一讲的图片（规律总结）</p>
<p>一般是在10<!-- raw HTML omitted -->7<!-- raw HTML omitted -->—10<!-- raw HTML omitted -->8<!-- raw HTML omitted --> 可以通过 如果超过10<!-- raw HTML omitted -->8<!-- raw HTML omitted --> 那么超时 同时可根据题目给出的范围 <strong>可大致判断出时间复杂度 从而大致判断出解题方法</strong></p>
<p>各种经典算法的时间复杂度</p>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 wcx blog
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.26.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
